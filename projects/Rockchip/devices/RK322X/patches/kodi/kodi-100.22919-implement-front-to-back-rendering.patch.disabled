diff -ruPN xbmc-20.1-Nexus/system/shaders/GL/1.2/gl_shader_vert.glsl xbmc-20.1-new/system/shaders/GL/1.2/gl_shader_vert.glsl
--- xbmc-20.1-Nexus/system/shaders/GL/1.2/gl_shader_vert.glsl	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/system/shaders/GL/1.2/gl_shader_vert.glsl	2023-03-14 17:08:52.440341727 +0100
@@ -29,11 +29,13 @@
 varying vec4 m_colour;
 uniform mat4 m_proj;
 uniform mat4 m_model;
+uniform float m_depth;
 
 void main ()
 {
   mat4 mvp    = m_proj * m_model;
   gl_Position = mvp * m_attrpos;
+  gl_Position.z = m_depth * gl_Position.w;
   m_colour    = m_attrcol;
   m_cord0     = m_attrcord0;
   m_cord1     = m_attrcord1;
diff -ruPN xbmc-20.1-Nexus/system/shaders/GL/1.2/gl_shader_vert_default.glsl xbmc-20.1-new/system/shaders/GL/1.2/gl_shader_vert_default.glsl
--- xbmc-20.1-Nexus/system/shaders/GL/1.2/gl_shader_vert_default.glsl	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/system/shaders/GL/1.2/gl_shader_vert_default.glsl	2023-03-14 17:08:52.451341727 +0100
@@ -28,4 +28,5 @@
 {
   mat4 mvp    = m_proj * m_model;
   gl_Position = mvp * m_attrpos;
+  gl_Position.z = -1. * gl_Position.w;
 }
diff -ruPN xbmc-20.1-Nexus/system/shaders/GL/1.2/gl_yuv2rgb_vertex.glsl xbmc-20.1-new/system/shaders/GL/1.2/gl_yuv2rgb_vertex.glsl
--- xbmc-20.1-Nexus/system/shaders/GL/1.2/gl_yuv2rgb_vertex.glsl	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/system/shaders/GL/1.2/gl_yuv2rgb_vertex.glsl	2023-03-14 17:08:52.451341727 +0100
@@ -32,6 +32,7 @@
 {
   mat4 mvp    = m_proj * m_model;
   gl_Position = mvp * m_attrpos;
+  gl_Position.z = -1. * gl_Position.w;
   m_cordY     = m_attrcordY;
   m_cordU     = m_attrcordU;
   m_cordV     = m_attrcordV;
diff -ruPN xbmc-20.1-Nexus/system/shaders/GL/1.5/gl_shader_vert.glsl xbmc-20.1-new/system/shaders/GL/1.5/gl_shader_vert.glsl
--- xbmc-20.1-Nexus/system/shaders/GL/1.5/gl_shader_vert.glsl	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/system/shaders/GL/1.5/gl_shader_vert.glsl	2023-03-14 17:08:52.440341727 +0100
@@ -9,11 +9,13 @@
 out vec4 m_colour;
 uniform mat4 m_proj;
 uniform mat4 m_model;
+uniform float m_depth;
 
 void main ()
 {
   mat4 mvp    = m_proj * m_model;
   gl_Position = mvp * m_attrpos;
+  gl_Position.z = m_depth * gl_Position.w;
   m_colour    = m_attrcol;
   m_cord0     = m_attrcord0;
   m_cord1     = m_attrcord1;
diff -ruPN xbmc-20.1-Nexus/system/shaders/GL/1.5/gl_shader_vert_default.glsl xbmc-20.1-new/system/shaders/GL/1.5/gl_shader_vert_default.glsl
--- xbmc-20.1-Nexus/system/shaders/GL/1.5/gl_shader_vert_default.glsl	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/system/shaders/GL/1.5/gl_shader_vert_default.glsl	2023-03-14 17:08:52.451341727 +0100
@@ -8,4 +8,5 @@
 {
   mat4 mvp    = m_proj * m_model;
   gl_Position = mvp * m_attrpos;
+  gl_Position.z = -1. * gl_Position.w;
 }
diff -ruPN xbmc-20.1-Nexus/system/shaders/GL/1.5/gl_yuv2rgb_vertex.glsl xbmc-20.1-new/system/shaders/GL/1.5/gl_yuv2rgb_vertex.glsl
--- xbmc-20.1-Nexus/system/shaders/GL/1.5/gl_yuv2rgb_vertex.glsl	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/system/shaders/GL/1.5/gl_yuv2rgb_vertex.glsl	2023-03-14 17:08:52.451341727 +0100
@@ -14,6 +14,7 @@
 {
   mat4 mvp = m_proj * m_model;
   gl_Position = mvp * m_attrpos;
+  gl_Position.z = -1. * gl_Position.w;
   m_cordY = m_attrcordY;
   m_cordU = m_attrcordU;
   m_cordV = m_attrcordV;
diff -ruPN xbmc-20.1-Nexus/system/shaders/GLES/2.0/gles_shader.vert xbmc-20.1-new/system/shaders/GLES/2.0/gles_shader.vert
--- xbmc-20.1-Nexus/system/shaders/GLES/2.0/gles_shader.vert	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/system/shaders/GLES/2.0/gles_shader.vert	2023-03-14 17:08:52.441341727 +0100
@@ -30,11 +30,13 @@
 uniform mat4 m_proj;
 uniform mat4 m_model;
 uniform mat4 m_coord0Matrix;
+uniform float m_depth;
 
 void main ()
 {
   mat4 mvp = m_proj * m_model;
   gl_Position = mvp * m_attrpos;
+  gl_Position.z = m_depth * gl_Position.w;
   m_colour = m_attrcol;
   m_cord0 = m_coord0Matrix * m_attrcord0;
   m_cord1 = m_attrcord1;
diff -ruPN xbmc-20.1-Nexus/system/shaders/GLES/2.0/gles_yuv2rgb.vert xbmc-20.1-new/system/shaders/GLES/2.0/gles_yuv2rgb.vert
--- xbmc-20.1-Nexus/system/shaders/GLES/2.0/gles_yuv2rgb.vert	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/system/shaders/GLES/2.0/gles_yuv2rgb.vert	2023-03-14 17:08:52.451341727 +0100
@@ -34,6 +34,7 @@
 {
   mat4 mvp = m_proj * m_model;
   gl_Position = mvp * m_attrpos;
+  gl_Position.z = -1. * gl_Position.w;
   m_cordY = m_attrcordY;
   m_cordU = m_attrcordU;
   m_cordV = m_attrcordV;
diff -ruPN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodec.cpp xbmc-20.1-new/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodec.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodec.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodec.cpp	2023-03-14 17:08:52.451341727 +0100
@@ -113,8 +113,6 @@
   CYuvPlane &plane = m_buffers[index].fields[0][0];
   CYuvPlane &planef = m_buffers[index].fields[m_currentField][0];
 
-  glDisable(GL_DEPTH_TEST);
-
   glActiveTexture(GL_TEXTURE0);
   glBindTexture(GL_TEXTURE_EXTERNAL_OES, plane.id);
 
diff -ruPN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp xbmc-20.1-new/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp	2023-03-14 17:08:52.451341727 +0100
@@ -528,9 +528,56 @@
 void CLinuxRendererGL::ClearBackBuffer()
 {
   //set the entire backbuffer to black
-  glClearColor(m_clearColour, m_clearColour, m_clearColour, 0);
-  glClear(GL_COLOR_BUFFER_BIT);
-  glClearColor(0,0,0,0);
+  //if we do a two pass render, we have to draw a quad. else we might occlude OSD elements.
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_ALL_BACK_TO_FRONT)
+  {
+    CServiceBroker::GetWinSystem()->GetGfxContext().Clear(0xff000000);
+  }
+  else
+  {
+    ClearBackBufferQuad();
+  }
+}
+
+void CLinuxRendererGL::ClearBackBufferQuad()
+{
+  CRect windowRect(0, 0, CServiceBroker::GetWinSystem()->GetGfxContext().GetWidth(),
+                   CServiceBroker::GetWinSystem()->GetGfxContext().GetHeight());
+  struct Svertex
+  {
+    float x, y;
+  };
+
+  std::vector<Svertex> vertices{
+      {windowRect.x1, windowRect.y2 * 2},
+      {windowRect.x1, windowRect.y1},
+      {windowRect.x2 * 2, windowRect.y1},
+  };
+
+  glDisable(GL_BLEND);
+
+  m_renderSystem->EnableShader(ShaderMethodGL::SM_DEFAULT);
+  GLint posLoc = m_renderSystem->ShaderGetPos();
+  GLint uniCol = m_renderSystem->ShaderGetUniCol();
+
+  glUniform4f(uniCol, m_clearColour / 255.0f, m_clearColour / 255.0f, m_clearColour / 255.0f, 1.0f);
+
+  GLuint vertexVBO;
+  glGenBuffers(1, &vertexVBO);
+  glBindBuffer(GL_ARRAY_BUFFER, vertexVBO);
+  glBufferData(GL_ARRAY_BUFFER, sizeof(Svertex) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
+
+  glVertexAttribPointer(posLoc, 2, GL_FLOAT, GL_FALSE, sizeof(Svertex), 0);
+  glEnableVertexAttribArray(posLoc);
+
+  glDrawArrays(GL_TRIANGLES, 0, vertices.size());
+
+  glDisableVertexAttribArray(posLoc);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers(1, &vertexVBO);
+
+  m_renderSystem->DisableShader();
 }
 
 //draw black bars around the video quad, this is more efficient than glClear()
@@ -1044,8 +1091,6 @@
     LoadShaders(field);
   }
 
-  glDisable(GL_DEPTH_TEST);
-
   // Y
   glActiveTexture(GL_TEXTURE0);
   glBindTexture(m_textureTarget, planes[0].id);
@@ -1216,8 +1261,6 @@
     }
   }
 
-  glDisable(GL_DEPTH_TEST);
-
   // Y
   glActiveTexture(GL_TEXTURE0);
   glBindTexture(m_textureTarget, planes[0].id);
diff -ruPN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.h xbmc-20.1-new/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.h
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.h	2023-03-14 17:08:52.441341727 +0100
@@ -87,6 +87,7 @@
 
   bool Render(unsigned int flags, int renderBuffer);
   void ClearBackBuffer();
+  void ClearBackBufferQuad();
   void DrawBlackBars();
 
   bool ValidateRenderer();
diff -ruPN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp xbmc-20.1-new/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp	2023-03-14 17:08:52.452341727 +0100
@@ -358,6 +358,61 @@
   ValidateRenderTarget();
 }
 
+void CLinuxRendererGLES::ClearBackBuffer()
+{
+  //set the entire backbuffer to black
+  //if we do a two pass render, we have to draw a quad. else we might occlude OSD elements.
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_ALL_BACK_TO_FRONT)
+  {
+    CServiceBroker::GetWinSystem()->GetGfxContext().Clear(0xff000000);
+  }
+  else
+  {
+    ClearBackBufferQuad();
+  }
+}
+
+void CLinuxRendererGLES::ClearBackBufferQuad()
+{
+  CRect windowRect(0, 0, CServiceBroker::GetWinSystem()->GetGfxContext().GetWidth(),
+                   CServiceBroker::GetWinSystem()->GetGfxContext().GetHeight());
+  struct Svertex
+  {
+    float x, y;
+  };
+
+  std::vector<Svertex> vertices{
+      {windowRect.x1, windowRect.y2 * 2},
+      {windowRect.x1, windowRect.y1},
+      {windowRect.x2 * 2, windowRect.y1},
+  };
+
+  glDisable(GL_BLEND);
+
+  m_renderSystem->EnableGUIShader(ShaderMethodGLES::SM_DEFAULT);
+  GLint posLoc = m_renderSystem->GUIShaderGetPos();
+  GLint uniCol = m_renderSystem->GUIShaderGetUniCol();
+
+  glUniform4f(uniCol, m_clearColour / 255.0f, m_clearColour / 255.0f, m_clearColour / 255.0f, 1.0f);
+
+  GLuint vertexVBO;
+  glGenBuffers(1, &vertexVBO);
+  glBindBuffer(GL_ARRAY_BUFFER, vertexVBO);
+  glBufferData(GL_ARRAY_BUFFER, sizeof(Svertex) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
+
+  glVertexAttribPointer(posLoc, 2, GL_FLOAT, GL_FALSE, sizeof(Svertex), 0);
+  glEnableVertexAttribArray(posLoc);
+
+  glDrawArrays(GL_TRIANGLES, 0, vertices.size());
+
+  glDisableVertexAttribArray(posLoc);
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+  glDeleteBuffers(1, &vertexVBO);
+
+  m_renderSystem->DisableGUIShader();
+}
+
 void CLinuxRendererGLES::DrawBlackBars()
 {
   CRect windowRect(0, 0, CServiceBroker::GetWinSystem()->GetGfxContext().GetWidth(),
@@ -432,6 +487,9 @@
   // if its first pass, just init textures and return
   if (ValidateRenderTarget())
   {
+    if (clear) //if clear is set, we're expected to overwrite all backbuffer pixels, even if we have nothing to render
+      ClearBackBuffer();
+
     return;
   }
 
@@ -456,9 +514,7 @@
       DrawBlackBars();
     else
     {
-      glClearColor(m_clearColour, m_clearColour, m_clearColour, 0);
-      glClear(GL_COLOR_BUFFER_BIT);
-      glClearColor(0, 0, 0, 0);
+      ClearBackBuffer();
     }
   }
 
@@ -490,7 +546,8 @@
     }
   }
 
-  Render(flags, index);
+  if (!Render(flags, index) && clear)
+    ClearBackBuffer();
 
   VerifyGLState();
   glEnable(GL_BLEND);
@@ -783,7 +840,7 @@
   return ret;
 }
 
-void CLinuxRendererGLES::Render(unsigned int flags, int index)
+bool CLinuxRendererGLES::Render(unsigned int flags, int index)
 {
   // obtain current field, if interlaced
   if( flags & RENDER_FLAG_TOP)
@@ -802,7 +859,7 @@
   // call texture load function
   if (!UploadTexture(index))
   {
-    return;
+    return false;
   }
 
   if (RenderHook(index))
@@ -832,8 +889,13 @@
       break;
     }
   }
+  else
+  {
+    return false;
+  }
 
   AfterRenderHook(index);
+  return true;
 }
 
 void CLinuxRendererGLES::RenderSinglePass(int index, int field)
@@ -872,8 +934,6 @@
     LoadShaders(field);
   }
 
-  glDisable(GL_DEPTH_TEST);
-
   // Y
   glActiveTexture(GL_TEXTURE0);
   glBindTexture(m_textureTarget, planes[0].id);
@@ -1023,8 +1083,6 @@
     }
   }
 
-  glDisable(GL_DEPTH_TEST);
-
   // Y
   glActiveTexture(GL_TEXTURE0);
   glBindTexture(m_textureTarget, planes[0].id);
diff -ruPN xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h xbmc-20.1-new/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h
--- xbmc-20.1-Nexus/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h	2023-03-14 17:08:52.453341727 +0100
@@ -91,7 +91,7 @@
   static const int FIELD_TOP{1};
   static const int FIELD_BOT{2};
 
-  virtual void Render(unsigned int flags, int index);
+  virtual bool Render(unsigned int flags, int index);
   virtual void RenderUpdateVideo(bool clear, unsigned int flags = 0, unsigned int alpha = 255);
 
   int NextYV12Texture();
@@ -212,5 +212,7 @@
   CRect m_viewRect;
 
 private:
+  void ClearBackBuffer();
+  void ClearBackBufferQuad();
   void DrawBlackBars();
 };
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIBaseContainer.cpp xbmc-20.1-new/xbmc/guilib/GUIBaseContainer.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIBaseContainer.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIBaseContainer.cpp	2023-03-14 17:08:52.442341727 +0100
@@ -272,6 +272,8 @@
     float focusedPos = 0;
     CGUIListItemPtr focusedItem;
     int current = offset - cacheBefore;
+
+    std::vector<RENDERITEM> renderitems;
     while (pos < end && m_items.size())
     {
       int itemNo = CorrectOffset(current, 0);
@@ -290,9 +292,9 @@
         else
         {
           if (m_orientation == VERTICAL)
-            RenderItem(origin.x, pos, item.get(), false);
+            renderitems.emplace_back(RENDERITEM{origin.x, pos, item, false});
           else
-            RenderItem(pos, origin.y, item.get(), false);
+            renderitems.emplace_back(RENDERITEM{pos, origin.y, item, false});
         }
       }
       // increment our position
@@ -303,9 +305,25 @@
     if (focusedItem)
     {
       if (m_orientation == VERTICAL)
-        RenderItem(origin.x, focusedPos, focusedItem.get(), true);
+        renderitems.emplace_back(RENDERITEM{origin.x, focusedPos, focusedItem, true});
       else
-        RenderItem(focusedPos, origin.y, focusedItem.get(), true);
+        renderitems.emplace_back(RENDERITEM{focusedPos, origin.y, focusedItem, true});
+    }
+
+    if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+        RENDER_ORDER_FRONT_TO_BACK)
+    {
+      for (auto it = std::crbegin(renderitems); it != std::crend(renderitems); it++)
+      {
+        RenderItem(it->posX, it->posY, it->item.get(), it->focused);
+      }
+    }
+    else
+    {
+      for (const auto& renderitem : renderitems)
+      {
+        RenderItem(renderitem.posX, renderitem.posY, renderitem.item.get(), renderitem.focused);
+      }
     }
 
     CServiceBroker::GetWinSystem()->GetGfxContext().RestoreClipRegion();
@@ -1025,6 +1043,37 @@
   UpdateListProvider();
 }
 
+void CGUIBaseContainer::AssignDepth()
+{
+  CGUIListItemPtr focusedItem = nullptr;
+  int32_t current = 0;
+
+  for (const auto& item : m_items)
+  {
+    bool focused = (current == GetOffset() + GetCursor());
+    if (focused)
+    {
+      focusedItem = item;
+    }
+    else
+    {
+      if (item->GetFocusedLayout())
+        item->GetFocusedLayout()->AssignDepth();
+      if (item->GetLayout())
+        item->GetLayout()->AssignDepth();
+    }
+    current++;
+  }
+
+  if (focusedItem)
+  {
+    if (focusedItem->GetFocusedLayout())
+      focusedItem->GetFocusedLayout()->AssignDepth();
+    if (focusedItem->GetLayout())
+      focusedItem->GetLayout()->AssignDepth();
+  }
+}
+
 void CGUIBaseContainer::UpdateListProvider(bool forceRefresh /* = false */)
 {
   if (m_listProvider)
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIBaseContainer.h xbmc-20.1-new/xbmc/guilib/GUIBaseContainer.h
--- xbmc-20.1-Nexus/xbmc/guilib/GUIBaseContainer.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIBaseContainer.h	2023-03-14 17:08:52.442341727 +0100
@@ -50,6 +50,7 @@
   void AllocResources() override;
   void FreeResources(bool immediately = false) override;
   void UpdateVisibility(const CGUIListItem *item = NULL) override;
+  void AssignDepth() override;
 
   virtual unsigned int GetRows() const;
 
@@ -233,6 +234,14 @@
   // early inertial scroll cancellation
   bool m_waitForScrollEnd = false;
   float m_lastScrollValue = 0.0f;
+
+  struct RENDERITEM
+  {
+    float posX;
+    float posY;
+    CGUIListItemPtr item;
+    bool focused;
+  };
 };
 
 
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIBorderedImage.cpp xbmc-20.1-new/xbmc/guilib/GUIBorderedImage.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIBorderedImage.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIBorderedImage.cpp	2023-03-14 17:08:52.453341727 +0100
@@ -56,9 +56,21 @@
 
 void CGUIBorderedImage::Render()
 {
+  bool renderFrontToBack = CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+                           RENDER_ORDER_FRONT_TO_BACK;
+
+  if (renderFrontToBack)
+  {
+    CGUIImage::Render();
+  }
+
   if (!m_borderImage->GetFileName().empty() && m_texture->ReadyToRender())
-    m_borderImage->Render();
-  CGUIImage::Render();
+    m_borderImage->Render(-1);
+
+  if (!renderFrontToBack)
+  {
+    CGUIImage::Render();
+  }
 }
 
 CRect CGUIBorderedImage::CalcRenderRegion() const
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIButtonControl.cpp xbmc-20.1-new/xbmc/guilib/GUIButtonControl.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIButtonControl.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIButtonControl.cpp	2023-03-14 17:08:52.453341727 +0100
@@ -106,15 +106,27 @@
 
 void CGUIButtonControl::Render()
 {
-  m_imgFocus->Render();
-  m_imgNoFocus->Render();
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+  {
+    m_imgNoFocus->Render();
+    m_imgFocus->Render(-1);
+  }
+  else
+  {
+    m_imgFocus->Render(-1);
+    m_imgNoFocus->Render();
+    RenderText();
+  }
 
-  RenderText();
   CGUIControl::Render();
 }
 
 void CGUIButtonControl::RenderText()
 {
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+    return;
   m_label.Render();
   m_label2.Render();
 }
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIControl.cpp xbmc-20.1-new/xbmc/guilib/GUIControl.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIControl.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIControl.cpp	2023-03-14 17:08:52.442341727 +0100
@@ -481,6 +481,11 @@
   return m_height;
 }
 
+void CGUIControl::AssignDepth()
+{
+  m_cachedTransform.depth = CServiceBroker::GetWinSystem()->GetGfxContext().GetDepth();
+}
+
 void CGUIControl::MarkDirtyRegion(const unsigned int dirtyState)
 {
   // if the control is culled, bail
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIControl.h xbmc-20.1-new/xbmc/guilib/GUIControl.h
--- xbmc-20.1-Nexus/xbmc/guilib/GUIControl.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIControl.h	2023-03-14 17:08:52.442341727 +0100
@@ -176,6 +176,7 @@
   virtual float GetYPosition() const;
   virtual float GetWidth() const;
   virtual float GetHeight() const;
+  virtual void AssignDepth();
 
   void MarkDirtyRegion(const unsigned int dirtyState = DIRTY_STATE_CONTROL);
   bool IsControlDirty() const { return m_controlDirtyState != 0; }
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIControlGroup.cpp xbmc-20.1-new/xbmc/guilib/GUIControlGroup.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIControlGroup.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIControlGroup.cpp	2023-03-14 17:08:52.454341727 +0100
@@ -105,12 +105,26 @@
   CPoint pos(GetPosition());
   CServiceBroker::GetWinSystem()->GetGfxContext().SetOrigin(pos.x, pos.y);
   CGUIControl *focusedControl = NULL;
-  for (auto *control : m_children)
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
   {
-    if (m_renderFocusedLast && control->HasFocus())
-      focusedControl = control;
-    else
-      control->DoRender();
+    for (auto it = m_children.rbegin(); it != m_children.rend(); ++it)
+    {
+      if (m_renderFocusedLast && (*it)->HasFocus())
+        focusedControl = (*it);
+      else
+        (*it)->DoRender();
+    }
+  }
+  else
+  {
+    for (auto* control : m_children)
+    {
+      if (m_renderFocusedLast && control->HasFocus())
+        focusedControl = control;
+      else
+        control->DoRender();
+    }
   }
   if (focusedControl)
     focusedControl->DoRender();
@@ -284,6 +298,23 @@
   return false;
 }
 
+void CGUIControlGroup::AssignDepth()
+{
+  CGUIControl *focusedControl = nullptr;
+  if (m_children.size())
+  {
+    for (auto* control : m_children)
+    {
+      if (m_renderFocusedLast && control->HasFocus())
+        focusedControl = control;
+      else
+        control->AssignDepth();
+    }
+  }
+  if(focusedControl)
+    focusedControl->AssignDepth();
+}
+
 void CGUIControlGroup::SetInitialVisibility()
 {
   CGUIControl::SetInitialVisibility();
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIControlGroup.h xbmc-20.1-new/xbmc/guilib/GUIControlGroup.h
--- xbmc-20.1-Nexus/xbmc/guilib/GUIControlGroup.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIControlGroup.h	2023-03-14 17:08:52.443341727 +0100
@@ -41,6 +41,7 @@
   void FreeResources(bool immediately = false) override;
   void DynamicResourceAlloc(bool bOnOff) override;
   bool CanFocus() const override;
+  void AssignDepth() override;
 
   EVENT_RESULT SendMouseEvent(const CPoint &point, const CMouseEvent &event) override;
   void UnfocusFromPoint(const CPoint &point) override;
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIEditControl.cpp xbmc-20.1-new/xbmc/guilib/GUIEditControl.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIEditControl.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIEditControl.cpp	2023-03-14 17:08:52.443341727 +0100
@@ -492,6 +492,9 @@
 
 void CGUIEditControl::RenderText()
 {
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+    return;
   m_label.Render();
 
   if (CServiceBroker::GetWinSystem()->GetGfxContext().SetClipRegion(m_clipRect.x1, m_clipRect.y1, m_clipRect.Width(), m_clipRect.Height()))
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIFadeLabelControl.cpp xbmc-20.1-new/xbmc/guilib/GUIFadeLabelControl.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIFadeLabelControl.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIFadeLabelControl.cpp	2023-03-14 17:08:52.443341727 +0100
@@ -170,6 +170,9 @@
 
 void CGUIFadeLabelControl::Render()
 {
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+    return;
   if (!m_label.font)
   { // nothing to render
     CGUIControl::Render();
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIFontTTFGL.cpp xbmc-20.1-new/xbmc/guilib/GUIFontTTFGL.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIFontTTFGL.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIFontTTFGL.cpp	2023-03-14 17:11:38.877348695 +0100
@@ -140,6 +140,7 @@
   GLint colLoc = renderSystem->ShaderGetCol();
   GLint tex0Loc = renderSystem->ShaderGetCoord0();
   GLint modelLoc = renderSystem->ShaderGetModel();
+  GLint depthLoc = renderSystem->ShaderGetDepth();
 
   CreateStaticVertexBuffers();
 
@@ -180,6 +181,9 @@
     glVertexAttribPointer(tex0Loc, 2, GL_FLOAT, GL_FALSE, sizeof(SVertex),
                           reinterpret_cast<const GLvoid*>(offsetof(SVertex, u)));
 
+    float depth = CServiceBroker::GetWinSystem()->GetGfxContext().GetTransformDepth();
+    glUniform1f(depthLoc, depth);
+
     glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
 
     glBindBuffer(GL_ARRAY_BUFFER, 0);
@@ -195,7 +199,7 @@
   GLint colLoc = renderSystem->GUIShaderGetCol();
   GLint tex0Loc = renderSystem->GUIShaderGetCoord0();
   GLint modelLoc = renderSystem->GUIShaderGetModel();
-
+  GLint depthLoc = renderSystem->ShaderGetDepth();
 
   CreateStaticVertexBuffers();
 
@@ -230,6 +234,8 @@
     glVertexAttribPointer(tex0Loc, 2, GL_FLOAT, GL_FALSE, sizeof(SVertex),
                           reinterpret_cast<char*>(vertices) + offsetof(SVertex, u));
 
+    float depth = CServiceBroker::GetWinSystem()->GetGfxContext().GetTransformDepth();
+    glUniform1f(depthLoc, depth);
     glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
   }
 #endif
@@ -269,6 +275,10 @@
                                        m_vertexTrans[i].m_translateZ);
       glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glMatrixModview.Get());
 
+      // Apply the depth value of the layer
+      float depth = CServiceBroker::GetWinSystem()->GetGfxContext().GetTransformDepth();
+      glUniform1f(depthLoc, depth);
+
       // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
       glBindBuffer(GL_ARRAY_BUFFER, m_vertexTrans[i].m_vertexBuffer->bufferHandle);
 
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUILabelControl.cpp xbmc-20.1-new/xbmc/guilib/GUILabelControl.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUILabelControl.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUILabelControl.cpp	2023-03-14 17:08:52.443341727 +0100
@@ -139,6 +139,9 @@
 
 void CGUILabelControl::Render()
 {
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+    return;
   m_label.Render();
   CGUIControl::Render();
 }
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIListItemLayout.cpp xbmc-20.1-new/xbmc/guilib/GUIListItemLayout.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIListItemLayout.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIListItemLayout.cpp	2023-03-14 17:08:52.443341727 +0100
@@ -237,6 +237,11 @@
   m_group.FreeResources(immediately);
 }
 
+void CGUIListItemLayout::AssignDepth()
+{
+  m_group.AssignDepth();
+}
+
 #ifdef _DEBUG
 void CGUIListItemLayout::DumpTextureUse()
 {
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIListItemLayout.h xbmc-20.1-new/xbmc/guilib/GUIListItemLayout.h
--- xbmc-20.1-Nexus/xbmc/guilib/GUIListItemLayout.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIListItemLayout.h	2023-03-14 17:08:52.443341727 +0100
@@ -34,6 +34,7 @@
   void SetInvalid() { m_invalidated = true; }
   void FreeResources(bool immediately = false);
   void SetParentControl(CGUIControl* control) { m_group.SetParentControl(control); }
+  void AssignDepth();
 
   //#ifdef GUILIB_PYTHON_COMPATIBILITY
   void CreateListControlLayouts(float width, float height, bool focused, const CLabelInfo &labelInfo, const CLabelInfo &labelInfo2, const CTextureInfo &texture, const CTextureInfo &textureFocus, float texHeight, float iconWidth, float iconHeight, const std::string &nofocusCondition, const std::string &focusCondition);
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIListLabel.cpp xbmc-20.1-new/xbmc/guilib/GUIListLabel.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIListLabel.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIListLabel.cpp	2023-03-14 17:08:52.443341727 +0100
@@ -67,6 +67,9 @@
 
 void CGUIListLabel::Render()
 {
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+    return;
   m_label.Render();
   CGUIControl::Render();
 }
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUISettingsSliderControl.cpp xbmc-20.1-new/xbmc/guilib/GUISettingsSliderControl.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUISettingsSliderControl.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUISettingsSliderControl.cpp	2023-03-14 17:08:52.443341727 +0100
@@ -48,6 +48,9 @@
 {
   m_buttonControl.Render();
   CGUISliderControl::Render();
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+    return;
   m_label.Render();
 }
 
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUISpinControl.cpp xbmc-20.1-new/xbmc/guilib/GUISpinControl.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUISpinControl.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUISpinControl.cpp	2023-03-14 17:08:52.444341727 +0100
@@ -551,6 +551,9 @@
 
 void CGUISpinControl::RenderText(float posX, float posY, float width, float height)
 {
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+    return;
   m_label.SetMaxRect(posX, posY, width, height);
   m_label.SetColor(GetTextColor());
   m_label.Render();
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUITextBox.cpp xbmc-20.1-new/xbmc/guilib/GUITextBox.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUITextBox.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUITextBox.cpp	2023-03-14 17:08:52.444341727 +0100
@@ -197,6 +197,10 @@
 
 void CGUITextBox::Render()
 {
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+    return;
+
   // render the repeat anim as appropriate
   if (m_autoScrollRepeatAnim)
     CServiceBroker::GetWinSystem()->GetGfxContext().SetTransform(m_cachedTextMatrix);
@@ -387,6 +391,12 @@
     m_autoScrollRepeatAnim->ResetAnimation();
 }
 
+void CGUITextBox::AssignDepth()
+{
+  CGUIControl::AssignDepth();
+  m_cachedTextMatrix.depth = m_cachedTransform.depth;
+}
+
 unsigned int CGUITextBox::GetRows() const
 {
   return m_lines.size();
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUITextBox.h xbmc-20.1-new/xbmc/guilib/GUITextBox.h
--- xbmc-20.1-Nexus/xbmc/guilib/GUITextBox.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUITextBox.h	2023-03-14 17:08:52.444341727 +0100
@@ -49,6 +49,7 @@
   void SetAutoScrolling(const TiXmlNode *node);
   void SetAutoScrolling(int delay, int time, int repeatTime, const std::string &condition = "");
   void ResetAutoScrolling();
+  void AssignDepth() override;
 
   bool GetCondition(int condition, int data) const override;
   virtual std::string GetLabel(int info) const;
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUITexture.cpp xbmc-20.1-new/xbmc/guilib/GUITexture.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUITexture.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUITexture.cpp	2023-03-14 17:08:52.455341728 +0100
@@ -9,6 +9,7 @@
 #include "GUITexture.h"
 
 #include "GUILargeTextureManager.h"
+#include "Texture.h"
 #include "TextureManager.h"
 #include "utils/MathUtils.h"
 #include "utils/StringUtils.h"
@@ -52,13 +53,18 @@
 void CGUITexture::DrawQuad(const CRect& coords,
                            UTILS::COLOR::Color color,
                            CTexture* texture,
-                           const CRect* texCoords)
+                           const CRect* texCoords,
+                           const float depth)
 {
+  // bail for now if we render front to back
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() == RENDER_ORDER_FRONT_TO_BACK)
+    return;
+
   if (!m_drawQuadFunc)
     throw std::runtime_error(
         "No GUITexture DrawQuad function available. Did you forget to register?");
 
-  m_drawQuadFunc(coords, color, texture, texCoords);
+  m_drawQuadFunc(coords, color, texture, texCoords, depth);
 }
 
 CGUITexture::CGUITexture(
@@ -163,18 +169,11 @@
   return changed;
 }
 
-void CGUITexture::Render()
+void CGUITexture::Render(int32_t depthOffset)
 {
   if (!m_visible || !m_texture.size())
     return;
 
-  // see if we need to clip the image
-  if (m_vertex.Width() > m_width || m_vertex.Height() > m_height)
-  {
-    if (!CServiceBroker::GetWinSystem()->GetGfxContext().SetClipRegion(m_posX, m_posY, m_width, m_height))
-      return;
-  }
-
   // set our draw color
   #define MIX_ALPHA(a,c) (((a * (c >> 24)) / 255) << 24) | (c & 0x00ffffff)
 
@@ -186,6 +185,28 @@
 
   color = CServiceBroker::GetWinSystem()->GetGfxContext().MergeColor(color);
 
+  m_depth = CServiceBroker::GetWinSystem()->GetGfxContext().GetTransformDepth(depthOffset);
+
+  bool hasAlpha =
+      (((color >> 24) & 0xFF) != 0xFF || m_texture.m_textures[m_currentFrame]->HasAlpha());
+  if (m_diffuse.size())
+    hasAlpha |= m_diffuse.m_textures[0]->HasAlpha();
+
+  // bail if it is not the appropriate render pass
+  RENDER_ORDER renderOrder = CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder();
+  if (hasAlpha && renderOrder == RENDER_ORDER_FRONT_TO_BACK)
+    return;
+  if (!hasAlpha && renderOrder == RENDER_ORDER_BACK_TO_FRONT)
+    return;
+
+  // see if we need to clip the image
+  if (m_vertex.Width() > m_width || m_vertex.Height() > m_height)
+  {
+    if (!CServiceBroker::GetWinSystem()->GetGfxContext().SetClipRegion(m_posX, m_posY, m_width,
+                                                                       m_height))
+      return;
+  }
+
   // setup our renderer
   Begin(color);
 
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUITexture.h xbmc-20.1-new/xbmc/guilib/GUITexture.h
--- xbmc-20.1-Nexus/xbmc/guilib/GUITexture.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUITexture.h	2023-03-14 17:08:52.455341728 +0100
@@ -68,7 +68,7 @@
 using CreateGUITextureFunc = std::function<CGUITexture*(
     float posX, float posY, float width, float height, const CTextureInfo& texture)>;
 using DrawQuadFunc = std::function<void(
-    const CRect& coords, UTILS::COLOR::Color color, CTexture* texture, const CRect* texCoords)>;
+    const CRect& coords, UTILS::COLOR::Color color, CTexture* texture, const CRect* texCoords, float depth)>;
 
 class CGUITexture
 {
@@ -85,10 +85,11 @@
   static void DrawQuad(const CRect& coords,
                        UTILS::COLOR::Color color,
                        CTexture* texture = nullptr,
-                       const CRect* texCoords = nullptr);
+                       const CRect* texCoords = nullptr,
+                       const float depth = 1.0);
 
   bool Process(unsigned int currentTime);
-  void Render();
+  void Render(int32_t depthOffset = 0);
 
   void DynamicResourceAlloc(bool bOnOff);
   bool AllocResources();
@@ -173,6 +174,7 @@
   float m_posY;
   float m_width;
   float m_height;
+  float m_depth{0};
 
   CRect m_vertex;       // vertex coords to render
   bool m_invalid;       // if true, we need to recalculate
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUITextureD3D.cpp xbmc-20.1-new/xbmc/guilib/GUITextureD3D.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUITextureD3D.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUITextureD3D.cpp	2023-03-14 17:08:52.455341728 +0100
@@ -140,7 +140,8 @@
 void CGUITextureD3D::DrawQuad(const CRect& rect,
                               UTILS::COLOR::Color color,
                               CTexture* texture,
-                              const CRect* texCoords)
+                              const CRect* texCoords,
+                              const float depth)
 {
   unsigned numViews = 0;
   ID3D11ShaderResourceView* views = nullptr;
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUITextureD3D.h xbmc-20.1-new/xbmc/guilib/GUITextureD3D.h
--- xbmc-20.1-Nexus/xbmc/guilib/GUITextureD3D.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUITextureD3D.h	2023-03-14 17:08:52.455341728 +0100
@@ -21,7 +21,8 @@
   static void DrawQuad(const CRect& coords,
                        UTILS::COLOR::Color color,
                        CTexture* texture = nullptr,
-                       const CRect* texCoords = nullptr);
+                       const CRect* texCoords = nullptr,
+                       const float depth = 1.0);
 
   CGUITextureD3D(float posX, float posY, float width, float height, const CTextureInfo& texture);
   ~CGUITextureD3D() override = default;
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUITextureGL.cpp xbmc-20.1-new/xbmc/guilib/GUITextureGL.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUITextureGL.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUITextureGL.cpp	2023-03-14 17:08:52.455341728 +0100
@@ -108,6 +108,7 @@
     GLint tex0Loc = m_renderSystem->ShaderGetCoord0();
     GLint tex1Loc = m_renderSystem->ShaderGetCoord1();
     GLint uniColLoc = m_renderSystem->ShaderGetUniCol();
+    GLint depthLoc = m_renderSystem->ShaderGetDepth();
 
     GLuint VertexVBO;
     GLuint IndexVBO;
@@ -116,6 +117,8 @@
     glBindBuffer(GL_ARRAY_BUFFER, VertexVBO);
     glBufferData(GL_ARRAY_BUFFER, sizeof(PackedVertex)*m_packedVertices.size(), &m_packedVertices[0], GL_STATIC_DRAW);
 
+    glUniform1f(depthLoc, m_depth);
+
     if (uniColLoc >= 0)
     {
       glUniform4f(uniColLoc,(m_col[0] / 255.0f), (m_col[1] / 255.0f), (m_col[2] / 255.0f), (m_col[3] / 255.0f));
@@ -255,7 +258,8 @@
 void CGUITextureGL::DrawQuad(const CRect& rect,
                              UTILS::COLOR::Color color,
                              CTexture* texture,
-                             const CRect* texCoords)
+                             const CRect* texCoords,
+                             const float depth)
 {
   CRenderSystemGL *renderSystem = dynamic_cast<CRenderSystemGL*>(CServiceBroker::GetRenderSystem());
   if (texture)
@@ -288,6 +292,7 @@
   GLint posLoc = renderSystem->ShaderGetPos();
   GLint tex0Loc = renderSystem->ShaderGetCoord0();
   GLint uniColLoc = renderSystem->ShaderGetUniCol();
+  GLint depthLoc = renderSystem->ShaderGetDepth();
 
   // Setup Colors
   col[0] = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::R, color);
@@ -296,6 +301,7 @@
   col[3] = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::A, color);
 
   glUniform4f(uniColLoc, col[0] / 255.0f, col[1] / 255.0f, col[2] / 255.0f, col[3] / 255.0f);
+  glUniform1f(depthLoc, depth);
 
   // bottom left
   vertex[0].x = rect.x1;
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUITextureGL.h xbmc-20.1-new/xbmc/guilib/GUITextureGL.h
--- xbmc-20.1-Nexus/xbmc/guilib/GUITextureGL.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUITextureGL.h	2023-03-14 17:08:52.456341728 +0100
@@ -27,7 +27,8 @@
   static void DrawQuad(const CRect& coords,
                        UTILS::COLOR::Color color,
                        CTexture* texture = nullptr,
-                       const CRect* texCoords = nullptr);
+                       const CRect* texCoords = nullptr,
+                       const float depth = 1.0);
 
   CGUITextureGL(float posX, float posY, float width, float height, const CTextureInfo& texture);
   ~CGUITextureGL() override = default;
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUITextureGLES.cpp xbmc-20.1-new/xbmc/guilib/GUITextureGLES.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUITextureGLES.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUITextureGLES.cpp	2023-03-14 17:08:52.456341728 +0100
@@ -114,12 +114,15 @@
     GLint tex0Loc = m_renderSystem->GUIShaderGetCoord0();
     GLint tex1Loc = m_renderSystem->GUIShaderGetCoord1();
     GLint uniColLoc = m_renderSystem->GUIShaderGetUniCol();
+    GLint depthLoc = m_renderSystem->ShaderGetDepth();
 
     if(uniColLoc >= 0)
     {
       glUniform4f(uniColLoc,(m_col[0] / 255.0f), (m_col[1] / 255.0f), (m_col[2] / 255.0f), (m_col[3] / 255.0f));
     }
 
+    glUniform1f(depthLoc, m_depth);
+
     if(m_diffuse.size())
     {
       glVertexAttribPointer(tex1Loc, 2, GL_FLOAT, 0, sizeof(PackedVertex), (char*)&m_packedVertices[0] + offsetof(PackedVertex, u2));
@@ -234,7 +237,8 @@
 void CGUITextureGLES::DrawQuad(const CRect& rect,
                                UTILS::COLOR::Color color,
                                CTexture* texture,
-                               const CRect* texCoords)
+                               const CRect* texCoords,
+                               const float depth)
 {
   CRenderSystemGLES *renderSystem = dynamic_cast<CRenderSystemGLES*>(CServiceBroker::GetRenderSystem());
   if (texture)
@@ -261,6 +265,7 @@
   GLint posLoc   = renderSystem->GUIShaderGetPos();
   GLint tex0Loc  = renderSystem->GUIShaderGetCoord0();
   GLint uniColLoc= renderSystem->GUIShaderGetUniCol();
+  GLint depthLoc = renderSystem->ShaderGetDepth();
 
   glVertexAttribPointer(posLoc,  3, GL_FLOAT, 0, 0, ver);
   if (texture)
@@ -277,6 +282,7 @@
   col[3] = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::A, color);
 
   glUniform4f(uniColLoc, col[0] / 255.0f, col[1] / 255.0f, col[2] / 255.0f, col[3] / 255.0f);
+  glUniform1f(depthLoc, depth);
 
   ver[0][0] = ver[3][0] = rect.x1;
   ver[0][1] = ver[1][1] = rect.y1;
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUITextureGLES.h xbmc-20.1-new/xbmc/guilib/GUITextureGLES.h
--- xbmc-20.1-Nexus/xbmc/guilib/GUITextureGLES.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUITextureGLES.h	2023-03-14 17:08:52.456341728 +0100
@@ -36,7 +36,8 @@
   static void DrawQuad(const CRect& coords,
                        UTILS::COLOR::Color color,
                        CTexture* texture = nullptr,
-                       const CRect* texCoords = nullptr);
+                       const CRect* texCoords = nullptr,
+                       const float depth = 1.0);
 
   CGUITextureGLES(float posX, float posY, float width, float height, const CTextureInfo& texture);
   ~CGUITextureGLES() override = default;
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIVideoControl.cpp xbmc-20.1-new/xbmc/guilib/GUIVideoControl.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIVideoControl.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIVideoControl.cpp	2023-03-14 17:08:52.444341727 +0100
@@ -38,6 +38,9 @@
 
 void CGUIVideoControl::Render()
 {
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+    return;
   auto& components = CServiceBroker::GetAppComponents();
   const auto appPlayer = components.GetComponent<CApplicationPlayer>();
   if (appPlayer->IsRenderingVideo())
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIWindow.cpp xbmc-20.1-new/xbmc/guilib/GUIWindow.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIWindow.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIWindow.cpp	2023-03-14 17:08:52.444341727 +0100
@@ -1069,6 +1069,8 @@
   UTILS::COLOR::Color color = m_clearBackground;
   if (color)
     CServiceBroker::GetWinSystem()->GetGfxContext().Clear(color);
+  else
+    CServiceBroker::GetWinSystem()->GetGfxContext().Clear();
 }
 
 void CGUIWindow::SetID(int id)
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIWindowManager.cpp xbmc-20.1-new/xbmc/guilib/GUIWindowManager.cpp
--- xbmc-20.1-Nexus/xbmc/guilib/GUIWindowManager.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIWindowManager.cpp	2023-03-14 17:08:52.445341727 +0100
@@ -1213,6 +1213,19 @@
       pWindow->DoProcess(currentTime, m_dirtyregions);
   }
 
+  // assign depth values to all active controls
+  if (pWindow)
+    pWindow->AssignDepth();
+
+  std::vector<CGUIWindow*> activeDialogs = m_activeDialogs;
+  stable_sort(activeDialogs.begin(), activeDialogs.end(), RenderOrderSortFunction);
+
+  for (const auto& window : activeDialogs)
+  {
+    if (window->IsDialogRunning())
+      window->AssignDepth();
+  }
+
   for (auto& itr : m_dirtyregions)
     m_tracker.MarkDirtyRegion(itr);
 }
@@ -1239,6 +1252,14 @@
 
 void CGUIWindowManager::RenderPass() const
 {
+  if (CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_guiFrontToBackRendering)
+    RenderPassDual();
+  else
+    RenderPassSingle();
+}
+
+void CGUIWindowManager::RenderPassSingle() const
+{
   CGUIWindow* pWindow = GetWindow(GetActiveWindow());
   if (pWindow)
   {
@@ -1257,6 +1278,40 @@
   }
 }
 
+void CGUIWindowManager::RenderPassDual() const
+{
+  CGUIWindow* pWindow = GetWindow(GetActiveWindow());
+  if (pWindow)
+    pWindow->ClearBackground();
+
+  std::vector<CGUIWindow*> renderList = m_activeDialogs;
+  stable_sort(renderList.begin(), renderList.end(), RenderOrderSortFunction);
+
+  // first the opaque pass, rendering from front to back
+  CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderOrder(RENDER_ORDER_FRONT_TO_BACK);
+  for (auto it = renderList.rbegin(); it != renderList.rend(); ++it)
+  {
+    if ((*it)->IsDialogRunning())
+      (*it)->DoRender();
+  }
+
+  if (pWindow)
+    pWindow->DoRender();
+
+  // now we render all elements with transparency back to front
+  CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderOrder(RENDER_ORDER_BACK_TO_FRONT);
+  if (pWindow)
+  {
+    pWindow->DoRender();
+  }
+
+  for (const auto& window : renderList)
+  {
+    if (window->IsDialogRunning())
+      window->DoRender();
+  }
+}
+
 void CGUIWindowManager::RenderEx() const
 {
   CGUIWindow* pWindow = GetWindow(GetActiveWindow());
@@ -1326,6 +1381,7 @@
 
 void CGUIWindowManager::AfterRender()
 {
+  CServiceBroker::GetWinSystem()->GetGfxContext().ResetDepth();
   m_tracker.CleanMarkedRegions();
 
   CGUIWindow* pWindow = GetWindow(GetActiveWindow());
diff -ruPN xbmc-20.1-Nexus/xbmc/guilib/GUIWindowManager.h xbmc-20.1-new/xbmc/guilib/GUIWindowManager.h
--- xbmc-20.1-Nexus/xbmc/guilib/GUIWindowManager.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/guilib/GUIWindowManager.h	2023-03-14 17:08:52.445341727 +0100
@@ -231,6 +231,8 @@
 #endif
 private:
   void RenderPass() const;
+  void RenderPassSingle() const;
+  void RenderPassDual() const;
 
   void LoadNotOnDemandWindows();
   void UnloadNotOnDemandWindows();
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/RenderSystem.cpp xbmc-20.1-new/xbmc/rendering/RenderSystem.cpp
--- xbmc-20.1-Nexus/xbmc/rendering/RenderSystem.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/RenderSystem.cpp	2023-03-14 17:08:52.445341727 +0100
@@ -14,6 +14,7 @@
 #include "guilib/GUILabelControl.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/SettingsComponent.h"
+#include "utils/log.h"
 
 CRenderSystemBase::CRenderSystemBase()
 {
@@ -68,7 +69,7 @@
   }
 
   CServiceBroker::GetWinSystem()->GetGfxContext().lock();
-  CServiceBroker::GetWinSystem()->GetGfxContext().Clear();
+  CServiceBroker::GetWinSystem()->GetGfxContext().Clear(0);
 
   RESOLUTION_INFO res = CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo();
   CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderingResolution(res, true);
@@ -108,3 +109,22 @@
   CServiceBroker::GetWinSystem()->GetGfxContext().Flip(true, false);
 }
 
+void CRenderSystemBase::MatchGPUArchitecture()
+{
+  std::vector<std::string> manufactures{
+      "Arm", "ARM", "Mali", "MALI", "Broadcom", "BROADCOM", "VC4", "VC6",
+  };
+
+  for (const auto& manufacturer : manufactures)
+  {
+    if ((m_RenderVendor.find(manufacturer) != std::string::npos) ||
+        (m_RenderRenderer.find(manufacturer) != std::string::npos))
+    {
+      CLog::Log(LOGINFO, "Tile-Based Rendering GPU detected");
+      m_isTileBasedGPU = true;
+      return;
+    }
+  }
+
+  CLog::Log(LOGINFO, "Immediate Rendering GPU detected");
+}
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/RenderSystem.h xbmc-20.1-new/xbmc/rendering/RenderSystem.h
--- xbmc-20.1-Nexus/xbmc/rendering/RenderSystem.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/RenderSystem.h	2023-03-14 17:08:52.445341727 +0100
@@ -21,6 +21,13 @@
  *   This interface is very basic since a lot of the actual details will go in to the derived classes
  */
 
+enum DEPTH_CULLING
+{
+  DEPTH_CULLING_OFF = 0,
+  DEPTH_CULLING_BACK_TO_FRONT,
+  DEPTH_CULLING_FRONT_TO_BACK,
+};
+
 class CGUIImage;
 class CGUITextLayout;
 
@@ -37,7 +44,9 @@
   virtual bool BeginRender() = 0;
   virtual bool EndRender() = 0;
   virtual void PresentRender(bool rendered, bool videoLayer) = 0;
-  virtual bool ClearBuffers(UTILS::COLOR::Color color) = 0;
+  virtual bool ClearBuffers(UTILS::COLOR::Color color,
+                            bool forceClearColor = true,
+                            bool forceClearDepth = true) = 0;
   virtual bool IsExtSupported(const char* extension) const = 0;
 
   virtual void SetViewPort(const CRect& viewPort) = 0;
@@ -49,6 +58,8 @@
   virtual void SetScissors(const CRect &rect) = 0;
   virtual void ResetScissors() = 0;
 
+  virtual void SetDepthCulling(DEPTH_CULLING culling) {}
+
   virtual void CaptureStateBlock() = 0;
   virtual void ApplyStateBlock() = 0;
 
@@ -74,10 +85,13 @@
   virtual bool SupportsStereo(RENDER_STEREO_MODE mode) const;
   unsigned int GetMaxTextureSize() const { return m_maxTextureSize; }
   unsigned int GetMinDXTPitch() const { return m_minDXTPitch; }
+  bool IsTileBasedGPU() const { return m_isTileBasedGPU; }
 
   virtual void ShowSplash(const std::string& message);
 
 protected:
+  void MatchGPUArchitecture();
+
   bool                m_bRenderCreated;
   bool                m_bVSync;
   unsigned int        m_maxTextureSize;
@@ -88,6 +102,7 @@
   std::string   m_RenderVersion;
   int          m_RenderVersionMinor;
   int          m_RenderVersionMajor;
+  bool m_isTileBasedGPU{false};
   RENDER_STEREO_VIEW m_stereoView = RENDER_STEREO_VIEW_OFF;
   RENDER_STEREO_MODE m_stereoMode = RENDER_STEREO_MODE_OFF;
   bool m_limitedColorRange = false;
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/dx/RenderSystemDX.cpp xbmc-20.1-new/xbmc/rendering/dx/RenderSystemDX.cpp
--- xbmc-20.1-Nexus/xbmc/rendering/dx/RenderSystemDX.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/dx/RenderSystemDX.cpp	2023-03-14 17:08:52.445341727 +0100
@@ -328,11 +328,16 @@
   return true;
 }
 
-bool CRenderSystemDX::ClearBuffers(UTILS::COLOR::Color color)
+bool CRenderSystemDX::ClearBuffers(UTILS::COLOR::Color color,
+                                   bool forceClearColor,
+                                   bool forceClearDepth)
 {
   if (!m_bRenderCreated)
     return false;
 
+  if (!forceClearColor)
+    return true;
+
   float fColor[4];
   CD3DHelper::XMStoreColor(fColor, color);
   ID3D11RenderTargetView* pRTView = m_deviceResources->GetBackBuffer().GetRenderTarget();
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/dx/RenderSystemDX.h xbmc-20.1-new/xbmc/rendering/dx/RenderSystemDX.h
--- xbmc-20.1-Nexus/xbmc/rendering/dx/RenderSystemDX.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/dx/RenderSystemDX.h	2023-03-14 17:08:52.445341727 +0100
@@ -34,7 +34,7 @@
   bool BeginRender() override;
   bool EndRender() override;
   void PresentRender(bool rendered, bool videoLayer) override;
-  bool ClearBuffers(UTILS::COLOR::Color color) override;
+  bool ClearBuffers(UTILS::COLOR::Color color, bool forceClearColor, bool forceClearDepth) override;
   void SetViewPort(const CRect& viewPort) override;
   void GetViewPort(CRect& viewPort) override;
   void RestoreViewPort() override;
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/gl/GLShader.cpp xbmc-20.1-new/xbmc/rendering/gl/GLShader.cpp
--- xbmc-20.1-Nexus/xbmc/rendering/gl/GLShader.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/gl/GLShader.cpp	2023-03-14 17:08:52.445341727 +0100
@@ -49,6 +49,7 @@
   // Variables passed directly to the Vertex shader
   m_hProj = glGetUniformLocation(ProgramHandle(), "m_proj");
   m_hModel = glGetUniformLocation(ProgramHandle(), "m_model");
+  m_hDepth = glGetUniformLocation(ProgramHandle(), "m_depth");
 
   // Vertex attributes
   m_hPos = glGetAttribLocation(ProgramHandle(),  "m_attrpos");
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/gl/GLShader.h xbmc-20.1-new/xbmc/rendering/gl/GLShader.h
--- xbmc-20.1-Nexus/xbmc/rendering/gl/GLShader.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/gl/GLShader.h	2023-03-14 17:08:52.445341727 +0100
@@ -25,6 +25,7 @@
   GLint GetColLoc() {return m_hCol;}
   GLint GetCord0Loc() {return m_hCord0;}
   GLint GetCord1Loc() {return m_hCord1;}
+  GLint GetDepthLoc() { return m_hDepth; }
   GLint GetUniColLoc() {return m_hUniCol;}
   GLint GetModelLoc() {return m_hModel; }
   bool HardwareClipIsPossible() {return m_clipPossible; }
@@ -43,6 +44,7 @@
   GLint m_hCol = 0;
   GLint m_hCord0 = 0;
   GLint m_hCord1 = 0;
+  GLint m_hDepth = 0;
 
   const GLfloat *m_proj = nullptr;
   const GLfloat *m_model = nullptr;
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/gl/RenderSystemGL.cpp xbmc-20.1-new/xbmc/rendering/gl/RenderSystemGL.cpp
--- xbmc-20.1-Nexus/xbmc/rendering/gl/RenderSystemGL.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/gl/RenderSystemGL.cpp	2023-03-14 17:08:52.446341727 +0100
@@ -96,6 +96,8 @@
   if (tmpRenderer != NULL)
     m_RenderRenderer = tmpRenderer;
 
+  MatchGPUArchitecture();
+
   m_bRenderCreated = true;
 
   if (m_RenderVersionMajor > 3 ||
@@ -232,7 +234,9 @@
   return true;
 }
 
-bool CRenderSystemGL::ClearBuffers(UTILS::COLOR::Color color)
+bool CRenderSystemGL::ClearBuffers(UTILS::COLOR::Color color,
+                                   bool forceClearColor,
+                                   bool forceClearDepth)
 {
   if (!m_bRenderCreated)
     return false;
@@ -241,14 +245,27 @@
   if(m_stereoMode == RENDER_STEREO_MODE_INTERLACED && m_stereoView == RENDER_STEREO_VIEW_RIGHT)
     return true;
 
-  float r = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::R, color) / 255.0f;
-  float g = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::G, color) / 255.0f;
-  float b = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::B, color) / 255.0f;
-  float a = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::A, color) / 255.0f;
+  GLbitfield flags = 0;
+
+  if (forceClearColor || m_isTileBasedGPU)
+  {
+    float r = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::R, color) / 255.0f;
+    float g = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::G, color) / 255.0f;
+    float b = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::B, color) / 255.0f;
+    float a = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::A, color) / 255.0f;
+
+    glClearColor(r, g, b, a);
 
-  glClearColor(r, g, b, a);
+    flags = GL_COLOR_BUFFER_BIT;
+  }
+
+  if (forceClearDepth)
+  {
+    flags |= GL_DEPTH_BUFFER_BIT;
+    glClearDepthf(0);
+    glDepthMask(true);
+  };
 
-  GLbitfield flags = GL_COLOR_BUFFER_BIT;
   glClear(flags);
 
   return true;
@@ -471,6 +488,27 @@
   SetScissors(CRect(0, 0, (float)m_width, (float)m_height));
 }
 
+void CRenderSystemGL::SetDepthCulling(DEPTH_CULLING culling)
+{
+  if (culling == DEPTH_CULLING_OFF)
+  {
+    glDisable(GL_DEPTH_TEST);
+    glDepthMask(GL_FALSE);
+  }
+  else if (culling == DEPTH_CULLING_BACK_TO_FRONT)
+  {
+    glEnable(GL_DEPTH_TEST);
+    glDepthMask(GL_FALSE);
+    glDepthFunc(GL_GEQUAL);
+  }
+  else if (culling == DEPTH_CULLING_FRONT_TO_BACK)
+  {
+    glEnable(GL_DEPTH_TEST);
+    glDepthMask(GL_TRUE);
+    glDepthFunc(GL_GREATER);
+  }
+}
+
 void CRenderSystemGL::GetGLSLVersion(int& major, int& minor)
 {
   major = m_glslMajor;
@@ -760,6 +798,14 @@
 
   return -1;
 }
+
+GLint CRenderSystemGL::ShaderGetDepth()
+{
+  if (m_pShader[m_method])
+    return m_pShader[m_method]->GetDepthLoc();
+
+  return -1;
+}
 
 GLint CRenderSystemGL::ShaderGetUniCol()
 {
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/gl/RenderSystemGL.cpp.orig xbmc-20.1-new/xbmc/rendering/gl/RenderSystemGL.cpp.orig
--- xbmc-20.1-Nexus/xbmc/rendering/gl/RenderSystemGL.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/gl/RenderSystemGL.cpp.orig	2023-03-11 23:16:38.000000000 +0100
@@ -0,0 +1,795 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "RenderSystemGL.h"
+
+#include "ServiceBroker.h"
+#include "URL.h"
+#include "guilib/GUITextureGL.h"
+#include "rendering/MatrixGL.h"
+#include "utils/FileUtils.h"
+#include "utils/GLUtils.h"
+#include "utils/MathUtils.h"
+#include "utils/XTimeUtils.h"
+#include "utils/log.h"
+#include "windowing/WinSystem.h"
+
+using namespace std::chrono_literals;
+
+CRenderSystemGL::CRenderSystemGL() : CRenderSystemBase()
+{
+}
+
+CRenderSystemGL::~CRenderSystemGL() = default;
+
+bool CRenderSystemGL::InitRenderSystem()
+{
+  m_bVSync = false;
+  m_bVsyncInit = false;
+  m_maxTextureSize = 2048;
+
+  // Get the GL version number
+  m_RenderVersionMajor = 0;
+  m_RenderVersionMinor = 0;
+  const char* ver = (const char*)glGetString(GL_VERSION);
+  if (ver != 0)
+  {
+    sscanf(ver, "%d.%d", &m_RenderVersionMajor, &m_RenderVersionMinor);
+    m_RenderVersion = ver;
+  }
+
+  CLog::Log(LOGINFO, "CRenderSystemGL::{} - Version: {}, Major: {}, Minor: {}", __FUNCTION__, ver,
+            m_RenderVersionMajor, m_RenderVersionMinor);
+
+  m_RenderExtensions  = " ";
+  if (m_RenderVersionMajor > 3 ||
+      (m_RenderVersionMajor == 3 && m_RenderVersionMinor >= 2))
+  {
+    GLint n = 0;
+    glGetIntegerv(GL_NUM_EXTENSIONS, &n);
+    if (n > 0)
+    {
+      GLint i;
+      for (i = 0; i < n; i++)
+      {
+        m_RenderExtensions += (const char*) glGetStringi(GL_EXTENSIONS, i);
+        m_RenderExtensions += " ";
+      }
+    }
+  }
+  else
+  {
+    auto extensions = (const char*) glGetString(GL_EXTENSIONS);
+    if (extensions)
+    {
+      m_RenderExtensions += extensions;
+    }
+  }
+  m_RenderExtensions += " ";
+
+  ver = (const char*)glGetString(GL_SHADING_LANGUAGE_VERSION);
+  if (ver)
+  {
+    sscanf(ver, "%d.%d", &m_glslMajor, &m_glslMinor);
+  }
+  else
+  {
+    m_glslMajor = 1;
+    m_glslMinor = 0;
+  }
+
+  LogGraphicsInfo();
+
+  // Get our driver vendor and renderer
+  const char* tmpVendor = (const char*) glGetString(GL_VENDOR);
+  m_RenderVendor.clear();
+  if (tmpVendor != NULL)
+    m_RenderVendor = tmpVendor;
+
+  const char* tmpRenderer = (const char*) glGetString(GL_RENDERER);
+  m_RenderRenderer.clear();
+  if (tmpRenderer != NULL)
+    m_RenderRenderer = tmpRenderer;
+
+  m_bRenderCreated = true;
+
+  if (m_RenderVersionMajor > 3 ||
+      (m_RenderVersionMajor == 3 && m_RenderVersionMinor >= 2))
+  {
+    glGenVertexArrays(1, &m_vertexArray);
+    glBindVertexArray(m_vertexArray);
+  }
+
+  InitialiseShaders();
+
+  CGUITextureGL::Register();
+
+  return true;
+}
+
+bool CRenderSystemGL::ResetRenderSystem(int width, int height)
+{
+  if (!m_bRenderCreated)
+    return false;
+
+  m_width = width;
+  m_height = height;
+
+  if (m_RenderVersionMajor > 3 ||
+      (m_RenderVersionMajor == 3 && m_RenderVersionMinor >= 2))
+  {
+    glBindVertexArray(0);
+    glDeleteVertexArrays(1, &m_vertexArray);
+    glGenVertexArrays(1, &m_vertexArray);
+    glBindVertexArray(m_vertexArray);
+  }
+
+  ReleaseShaders();
+  InitialiseShaders();
+
+  glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );
+
+  CalculateMaxTexturesize();
+
+  CRect rect( 0, 0, width, height );
+  SetViewPort( rect );
+
+  glEnable(GL_SCISSOR_TEST);
+
+  glMatrixProject.Clear();
+  glMatrixProject->LoadIdentity();
+  glMatrixProject->Ortho(0.0f, width-1, height-1, 0.0f, -1.0f, 1.0f);
+  glMatrixProject.Load();
+
+  glMatrixModview.Clear();
+  glMatrixModview->LoadIdentity();
+  glMatrixModview.Load();
+
+  glMatrixTexture.Clear();
+  glMatrixTexture->LoadIdentity();
+  glMatrixTexture.Load();
+
+  if (IsExtSupported("GL_ARB_multitexture"))
+  {
+    //clear error flags
+    ResetGLErrors();
+
+    GLint maxtex;
+    glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS, &maxtex);
+
+    //some sanity checks
+    GLenum error = glGetError();
+    if (error != GL_NO_ERROR)
+    {
+      CLog::Log(LOGERROR, "ResetRenderSystem() GL_MAX_TEXTURE_IMAGE_UNITS returned error {}",
+                (int)error);
+      maxtex = 3;
+    }
+    else if (maxtex < 1 || maxtex > 32)
+    {
+      CLog::Log(LOGERROR,
+                "ResetRenderSystem() GL_MAX_TEXTURE_IMAGE_UNITS returned invalid value {}",
+                (int)maxtex);
+      maxtex = 3;
+    }
+
+    //reset texture matrix for all textures
+    for (GLint i = 0; i < maxtex; i++)
+    {
+      glActiveTexture(GL_TEXTURE0 + i);
+      glMatrixTexture.Load();
+    }
+    glActiveTexture(GL_TEXTURE0);
+  }
+
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE);
+  glEnable(GL_BLEND);          // Turn Blending On
+  glDisable(GL_DEPTH_TEST);
+
+  return true;
+}
+
+bool CRenderSystemGL::DestroyRenderSystem()
+{
+  if (m_vertexArray != GL_NONE)
+  {
+    glDeleteVertexArrays(1, &m_vertexArray);
+  }
+
+  ReleaseShaders();
+  m_bRenderCreated = false;
+
+  return true;
+}
+
+bool CRenderSystemGL::BeginRender()
+{
+  if (!m_bRenderCreated)
+    return false;
+
+  bool useLimited = CServiceBroker::GetWinSystem()->UseLimitedColor();
+
+  if (m_limitedColorRange != useLimited)
+  {
+    ReleaseShaders();
+    InitialiseShaders();
+  }
+
+  m_limitedColorRange = useLimited;
+  return true;
+}
+
+bool CRenderSystemGL::EndRender()
+{
+  if (!m_bRenderCreated)
+    return false;
+
+  return true;
+}
+
+bool CRenderSystemGL::ClearBuffers(UTILS::COLOR::Color color)
+{
+  if (!m_bRenderCreated)
+    return false;
+
+  /* clear is not affected by stipple pattern, so we can only clear on first frame */
+  if(m_stereoMode == RENDER_STEREO_MODE_INTERLACED && m_stereoView == RENDER_STEREO_VIEW_RIGHT)
+    return true;
+
+  float r = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::R, color) / 255.0f;
+  float g = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::G, color) / 255.0f;
+  float b = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::B, color) / 255.0f;
+  float a = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::A, color) / 255.0f;
+
+  glClearColor(r, g, b, a);
+
+  GLbitfield flags = GL_COLOR_BUFFER_BIT;
+  glClear(flags);
+
+  return true;
+}
+
+bool CRenderSystemGL::IsExtSupported(const char* extension) const
+{
+  if (m_RenderVersionMajor > 3 ||
+      (m_RenderVersionMajor == 3 && m_RenderVersionMinor >= 2))
+  {
+    if (strcmp( extension, "GL_EXT_framebuffer_object") == 0)
+    {
+      return true;
+    }
+    if (strcmp( extension, "GL_ARB_texture_non_power_of_two") == 0)
+    {
+      return true;
+    }
+  }
+
+  std::string name;
+  name  = " ";
+  name += extension;
+  name += " ";
+
+  return m_RenderExtensions.find(name) != std::string::npos;
+}
+
+bool CRenderSystemGL::SupportsNPOT(bool dxt) const
+{
+  return true;
+}
+
+void CRenderSystemGL::PresentRender(bool rendered, bool videoLayer)
+{
+  SetVSync(true);
+
+  if (!m_bRenderCreated)
+    return;
+
+  PresentRenderImpl(rendered);
+
+  if (!rendered)
+    KODI::TIME::Sleep(40ms);
+}
+
+void CRenderSystemGL::SetVSync(bool enable)
+{
+  if (m_bVSync == enable && m_bVsyncInit == true)
+    return;
+
+  if (!m_bRenderCreated)
+    return;
+
+  if (enable)
+    CLog::Log(LOGINFO, "GL: Enabling VSYNC");
+  else
+    CLog::Log(LOGINFO, "GL: Disabling VSYNC");
+
+  m_bVSync = enable;
+  m_bVsyncInit = true;
+
+  SetVSyncImpl(enable);
+}
+
+void CRenderSystemGL::CaptureStateBlock()
+{
+  if (!m_bRenderCreated)
+    return;
+
+  glMatrixProject.Push();
+  glMatrixModview.Push();
+  glMatrixTexture.Push();
+
+  glDisable(GL_SCISSOR_TEST); // fixes FBO corruption on Macs
+  glActiveTexture(GL_TEXTURE0);
+}
+
+void CRenderSystemGL::ApplyStateBlock()
+{
+  if (!m_bRenderCreated)
+    return;
+
+  glBindVertexArray(m_vertexArray);
+
+  glViewport(m_viewPort[0], m_viewPort[1], m_viewPort[2], m_viewPort[3]);
+
+  glMatrixProject.PopLoad();
+  glMatrixModview.PopLoad();
+  glMatrixTexture.PopLoad();
+
+  glActiveTexture(GL_TEXTURE0);
+  glEnable(GL_BLEND);
+  glEnable(GL_SCISSOR_TEST);
+}
+
+void CRenderSystemGL::SetCameraPosition(const CPoint &camera, int screenWidth, int screenHeight, float stereoFactor)
+{
+  if (!m_bRenderCreated)
+    return;
+
+  CPoint offset = camera - CPoint(screenWidth*0.5f, screenHeight*0.5f);
+
+
+  float w = (float)m_viewPort[2]*0.5f;
+  float h = (float)m_viewPort[3]*0.5f;
+
+  glMatrixModview->LoadIdentity();
+  glMatrixModview->Translatef(-(w + offset.x - stereoFactor), +(h + offset.y), 0);
+  glMatrixModview->LookAt(0.0f, 0.0f, -2.0f * h, 0.0f, 0.0f, 0.0f, 0.0f, -1.0f, 0.0f);
+  glMatrixModview.Load();
+
+  glMatrixProject->LoadIdentity();
+  glMatrixProject->Frustum( (-w - offset.x)*0.5f, (w - offset.x)*0.5f, (-h + offset.y)*0.5f, (h + offset.y)*0.5f, h, 100*h);
+  glMatrixProject.Load();
+}
+
+void CRenderSystemGL::Project(float &x, float &y, float &z)
+{
+  GLfloat coordX, coordY, coordZ;
+  if (CMatrixGL::Project(x, y, z, glMatrixModview.Get(), glMatrixProject.Get(), m_viewPort, &coordX, &coordY, &coordZ))
+  {
+    x = coordX;
+    y = (float)(m_viewPort[1] + m_viewPort[3] - coordY);
+    z = 0;
+  }
+}
+
+void CRenderSystemGL::CalculateMaxTexturesize()
+{
+  GLint width = 256;
+
+  // reset any previous GL errors
+  ResetGLErrors();
+
+  // max out at 2^(8+8)
+  for (int i = 0 ; i<8 ; i++)
+  {
+    glTexImage2D(GL_PROXY_TEXTURE_2D, 0, GL_RGBA, width, width, 0, GL_BGRA,
+                 GL_UNSIGNED_BYTE, NULL);
+    glGetTexLevelParameteriv(GL_PROXY_TEXTURE_2D, 0, GL_TEXTURE_WIDTH,
+                             &width);
+
+    // GMA950 on OS X sets error instead
+    if (width == 0 || (glGetError() != GL_NO_ERROR) )
+      break;
+
+    m_maxTextureSize = width;
+    width *= 2;
+    if (width > 65536) // have an upper limit in case driver acts stupid
+    {
+      CLog::Log(LOGERROR, "GL: Could not determine maximum texture width, falling back to 2048");
+      m_maxTextureSize = 2048;
+      break;
+    }
+  }
+
+  CLog::Log(LOGINFO, "GL: Maximum texture width: {}", m_maxTextureSize);
+}
+
+void CRenderSystemGL::GetViewPort(CRect& viewPort)
+{
+  if (!m_bRenderCreated)
+    return;
+
+  viewPort.x1 = m_viewPort[0];
+  viewPort.y1 = m_height - m_viewPort[1] - m_viewPort[3];
+  viewPort.x2 = m_viewPort[0] + m_viewPort[2];
+  viewPort.y2 = viewPort.y1 + m_viewPort[3];
+}
+
+void CRenderSystemGL::SetViewPort(const CRect& viewPort)
+{
+  if (!m_bRenderCreated)
+    return;
+
+  glScissor((GLint) viewPort.x1, (GLint) (m_height - viewPort.y1 - viewPort.Height()), (GLsizei) viewPort.Width(), (GLsizei) viewPort.Height());
+  glViewport((GLint) viewPort.x1, (GLint) (m_height - viewPort.y1 - viewPort.Height()), (GLsizei) viewPort.Width(), (GLsizei) viewPort.Height());
+  m_viewPort[0] = viewPort.x1;
+  m_viewPort[1] = m_height - viewPort.y1 - viewPort.Height();
+  m_viewPort[2] = viewPort.Width();
+  m_viewPort[3] = viewPort.Height();
+}
+
+bool CRenderSystemGL::ScissorsCanEffectClipping()
+{
+  if (m_pShader[m_method])
+    return m_pShader[m_method]->HardwareClipIsPossible();
+
+  return false;
+}
+
+CRect CRenderSystemGL::ClipRectToScissorRect(const CRect &rect)
+{
+  if (!m_pShader[m_method])
+    return CRect();
+  float xFactor = m_pShader[m_method]->GetClipXFactor();
+  float xOffset = m_pShader[m_method]->GetClipXOffset();
+  float yFactor = m_pShader[m_method]->GetClipYFactor();
+  float yOffset = m_pShader[m_method]->GetClipYOffset();
+  return CRect(rect.x1 * xFactor + xOffset,
+               rect.y1 * yFactor + yOffset,
+               rect.x2 * xFactor + xOffset,
+               rect.y2 * yFactor + yOffset);
+}
+
+void CRenderSystemGL::SetScissors(const CRect &rect)
+{
+  if (!m_bRenderCreated)
+    return;
+  GLint x1 = MathUtils::round_int(static_cast<double>(rect.x1));
+  GLint y1 = MathUtils::round_int(static_cast<double>(rect.y1));
+  GLint x2 = MathUtils::round_int(static_cast<double>(rect.x2));
+  GLint y2 = MathUtils::round_int(static_cast<double>(rect.y2));
+  glScissor(x1, m_height - y2, x2-x1, y2-y1);
+}
+
+void CRenderSystemGL::ResetScissors()
+{
+  SetScissors(CRect(0, 0, (float)m_width, (float)m_height));
+}
+
+void CRenderSystemGL::GetGLSLVersion(int& major, int& minor)
+{
+  major = m_glslMajor;
+  minor = m_glslMinor;
+}
+
+void CRenderSystemGL::ResetGLErrors()
+{
+  int count = 0;
+  while (glGetError() != GL_NO_ERROR)
+  {
+    count++;
+    if (count >= 100)
+    {
+      CLog::Log(
+          LOGWARNING,
+          "CRenderSystemGL::ResetGLErrors glGetError didn't return GL_NO_ERROR after {} iterations",
+          count);
+      break;
+    }
+  }
+}
+static const GLubyte stipple_3d[] = {
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+  0xFF, 0xFF, 0xFF, 0xFF,
+  0x00, 0x00, 0x00, 0x00,
+};
+
+void CRenderSystemGL::SetStereoMode(RENDER_STEREO_MODE mode, RENDER_STEREO_VIEW view)
+{
+  CRenderSystemBase::SetStereoMode(mode, view);
+
+  glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
+  glDrawBuffer(GL_BACK);
+
+  if(m_stereoMode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN)
+  {
+    if(m_stereoView == RENDER_STEREO_VIEW_LEFT)
+      glColorMask(GL_TRUE, GL_FALSE, GL_FALSE, GL_TRUE);
+    else if(m_stereoView == RENDER_STEREO_VIEW_RIGHT)
+      glColorMask(GL_FALSE, GL_TRUE, GL_TRUE, GL_TRUE);
+  }
+  if(m_stereoMode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)
+  {
+    if(m_stereoView == RENDER_STEREO_VIEW_LEFT)
+      glColorMask(GL_FALSE, GL_TRUE, GL_FALSE, GL_TRUE);
+    else if(m_stereoView == RENDER_STEREO_VIEW_RIGHT)
+      glColorMask(GL_TRUE, GL_FALSE, GL_TRUE, GL_TRUE);
+  }
+  if(m_stereoMode == RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE)
+  {
+    if(m_stereoView == RENDER_STEREO_VIEW_LEFT)
+      glColorMask(GL_TRUE, GL_TRUE, GL_FALSE, GL_TRUE);
+    else if(m_stereoView == RENDER_STEREO_VIEW_RIGHT)
+      glColorMask(GL_FALSE, GL_FALSE, GL_TRUE, GL_TRUE);
+  }
+
+  if(m_stereoMode == RENDER_STEREO_MODE_INTERLACED)
+  {
+    glEnable(GL_POLYGON_STIPPLE);
+    if(m_stereoView == RENDER_STEREO_VIEW_LEFT)
+      glPolygonStipple(stipple_3d);
+    else if(m_stereoView == RENDER_STEREO_VIEW_RIGHT)
+      glPolygonStipple(stipple_3d+4);
+  }
+
+  if(m_stereoMode == RENDER_STEREO_MODE_HARDWAREBASED)
+  {
+    if(m_stereoView == RENDER_STEREO_VIEW_LEFT)
+      glDrawBuffer(GL_BACK_LEFT);
+    else if(m_stereoView == RENDER_STEREO_VIEW_RIGHT)
+      glDrawBuffer(GL_BACK_RIGHT);
+  }
+
+}
+
+bool CRenderSystemGL::SupportsStereo(RENDER_STEREO_MODE mode) const
+{
+  switch(mode)
+  {
+    case RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN:
+    case RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA:
+    case RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE:
+    case RENDER_STEREO_MODE_INTERLACED:
+      return true;
+    case RENDER_STEREO_MODE_HARDWAREBASED: {
+      //This is called by setting init, at which point GL is not inited
+      //luckily if GL doesn't support this, it will just behave as if
+      //it was not in effect.
+      //GLboolean stereo = GL_FALSE;
+      //glGetBooleanv(GL_STEREO, &stereo);
+      //return stereo == GL_TRUE ? true : false;
+      return true;
+    }
+    default:
+      return CRenderSystemBase::SupportsStereo(mode);
+  }
+}
+
+// -----------------------------------------------------------------------------
+// shaders
+// -----------------------------------------------------------------------------
+void CRenderSystemGL::InitialiseShaders()
+{
+  std::string defines;
+  m_limitedColorRange = CServiceBroker::GetWinSystem()->UseLimitedColor();
+  if (m_limitedColorRange)
+  {
+    defines += "#define KODI_LIMITED_RANGE 1\n";
+  }
+
+  m_pShader[ShaderMethodGL::SM_DEFAULT] = std::make_unique<CGLShader>(
+      "gl_shader_vert_default.glsl", "gl_shader_frag_default.glsl", defines);
+  if (!m_pShader[ShaderMethodGL::SM_DEFAULT]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGL::SM_DEFAULT]->Free();
+    m_pShader[ShaderMethodGL::SM_DEFAULT].reset();
+    CLog::Log(LOGERROR, "GUI Shader gl_shader_frag_default.glsl - compile and link failed");
+  }
+
+  m_pShader[ShaderMethodGL::SM_TEXTURE] =
+      std::make_unique<CGLShader>("gl_shader_frag_texture.glsl", defines);
+  if (!m_pShader[ShaderMethodGL::SM_TEXTURE]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGL::SM_TEXTURE]->Free();
+    m_pShader[ShaderMethodGL::SM_TEXTURE].reset();
+    CLog::Log(LOGERROR, "GUI Shader gl_shader_frag_texture.glsl - compile and link failed");
+  }
+
+  m_pShader[ShaderMethodGL::SM_TEXTURE_LIM] =
+      std::make_unique<CGLShader>("gl_shader_frag_texture_lim.glsl", defines);
+  if (!m_pShader[ShaderMethodGL::SM_TEXTURE_LIM]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGL::SM_TEXTURE_LIM]->Free();
+    m_pShader[ShaderMethodGL::SM_TEXTURE_LIM].reset();
+    CLog::Log(LOGERROR, "GUI Shader gl_shader_frag_texture_lim.glsl - compile and link failed");
+  }
+
+  m_pShader[ShaderMethodGL::SM_MULTI] =
+      std::make_unique<CGLShader>("gl_shader_frag_multi.glsl", defines);
+  if (!m_pShader[ShaderMethodGL::SM_MULTI]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGL::SM_MULTI]->Free();
+    m_pShader[ShaderMethodGL::SM_MULTI].reset();
+    CLog::Log(LOGERROR, "GUI Shader gl_shader_frag_multi.glsl - compile and link failed");
+  }
+
+  m_pShader[ShaderMethodGL::SM_FONTS] =
+      std::make_unique<CGLShader>("gl_shader_frag_fonts.glsl", defines);
+  if (!m_pShader[ShaderMethodGL::SM_FONTS]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGL::SM_FONTS]->Free();
+    m_pShader[ShaderMethodGL::SM_FONTS].reset();
+    CLog::Log(LOGERROR, "GUI Shader gl_shader_frag_fonts.glsl - compile and link failed");
+  }
+
+  m_pShader[ShaderMethodGL::SM_TEXTURE_NOBLEND] =
+      std::make_unique<CGLShader>("gl_shader_frag_texture_noblend.glsl", defines);
+  if (!m_pShader[ShaderMethodGL::SM_TEXTURE_NOBLEND]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGL::SM_TEXTURE_NOBLEND]->Free();
+    m_pShader[ShaderMethodGL::SM_TEXTURE_NOBLEND].reset();
+    CLog::Log(LOGERROR, "GUI Shader gl_shader_frag_texture_noblend.glsl - compile and link failed");
+  }
+
+  m_pShader[ShaderMethodGL::SM_MULTI_BLENDCOLOR] =
+      std::make_unique<CGLShader>("gl_shader_frag_multi_blendcolor.glsl", defines);
+  if (!m_pShader[ShaderMethodGL::SM_MULTI_BLENDCOLOR]->CompileAndLink())
+  {
+    m_pShader[ShaderMethodGL::SM_MULTI_BLENDCOLOR]->Free();
+    m_pShader[ShaderMethodGL::SM_MULTI_BLENDCOLOR].reset();
+    CLog::Log(LOGERROR, "GUI Shader gl_shader_frag_multi_blendcolor.glsl - compile and link failed");
+  }
+}
+
+void CRenderSystemGL::ReleaseShaders()
+{
+  if (m_pShader[ShaderMethodGL::SM_DEFAULT])
+    m_pShader[ShaderMethodGL::SM_DEFAULT]->Free();
+  m_pShader[ShaderMethodGL::SM_DEFAULT].reset();
+
+  if (m_pShader[ShaderMethodGL::SM_TEXTURE])
+    m_pShader[ShaderMethodGL::SM_TEXTURE]->Free();
+  m_pShader[ShaderMethodGL::SM_TEXTURE].reset();
+
+  if (m_pShader[ShaderMethodGL::SM_TEXTURE_LIM])
+    m_pShader[ShaderMethodGL::SM_TEXTURE_LIM]->Free();
+  m_pShader[ShaderMethodGL::SM_TEXTURE_LIM].reset();
+
+  if (m_pShader[ShaderMethodGL::SM_MULTI])
+    m_pShader[ShaderMethodGL::SM_MULTI]->Free();
+  m_pShader[ShaderMethodGL::SM_MULTI].reset();
+
+  if (m_pShader[ShaderMethodGL::SM_FONTS])
+    m_pShader[ShaderMethodGL::SM_FONTS]->Free();
+  m_pShader[ShaderMethodGL::SM_FONTS].reset();
+
+  if (m_pShader[ShaderMethodGL::SM_TEXTURE_NOBLEND])
+    m_pShader[ShaderMethodGL::SM_TEXTURE_NOBLEND]->Free();
+  m_pShader[ShaderMethodGL::SM_TEXTURE_NOBLEND].reset();
+
+  if (m_pShader[ShaderMethodGL::SM_MULTI_BLENDCOLOR])
+    m_pShader[ShaderMethodGL::SM_MULTI_BLENDCOLOR]->Free();
+  m_pShader[ShaderMethodGL::SM_MULTI_BLENDCOLOR].reset();
+}
+
+void CRenderSystemGL::EnableShader(ShaderMethodGL method)
+{
+  m_method = method;
+  if (m_pShader[m_method])
+  {
+    m_pShader[m_method]->Enable();
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "Invalid GUI Shader selected {}", method);
+  }
+}
+
+void CRenderSystemGL::DisableShader()
+{
+  if (m_pShader[m_method])
+  {
+    m_pShader[m_method]->Disable();
+  }
+  m_method = ShaderMethodGL::SM_DEFAULT;
+}
+
+GLint CRenderSystemGL::ShaderGetPos()
+{
+  if (m_pShader[m_method])
+    return m_pShader[m_method]->GetPosLoc();
+
+  return -1;
+}
+
+GLint CRenderSystemGL::ShaderGetCol()
+{
+  if (m_pShader[m_method])
+    return m_pShader[m_method]->GetColLoc();
+
+  return -1;
+}
+
+GLint CRenderSystemGL::ShaderGetCoord0()
+{
+  if (m_pShader[m_method])
+    return m_pShader[m_method]->GetCord0Loc();
+
+  return -1;
+}
+
+GLint CRenderSystemGL::ShaderGetCoord1()
+{
+  if (m_pShader[m_method])
+    return m_pShader[m_method]->GetCord1Loc();
+
+  return -1;
+}
+
+GLint CRenderSystemGL::ShaderGetUniCol()
+{
+  if (m_pShader[m_method])
+    return m_pShader[m_method]->GetUniColLoc();
+
+  return -1;
+}
+
+GLint CRenderSystemGL::ShaderGetModel()
+{
+  if (m_pShader[m_method])
+    return m_pShader[m_method]->GetModelLoc();
+
+  return -1;
+}
+
+std::string CRenderSystemGL::GetShaderPath(const std::string &filename)
+{
+  std::string path = "GL/1.2/";
+
+  if (m_glslMajor >= 4)
+  {
+    std::string file = "special://xbmc/system/shaders/GL/4.0/" + filename;
+    const CURL pathToUrl(file);
+    if (CFileUtils::Exists(pathToUrl.Get()))
+      return "GL/4.0/";
+  }
+  if (m_glslMajor >= 2 || (m_glslMajor == 1 && m_glslMinor >= 50))
+    path = "GL/1.5/";
+
+  return path;
+}
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/gl/RenderSystemGL.h xbmc-20.1-new/xbmc/rendering/gl/RenderSystemGL.h
--- xbmc-20.1-Nexus/xbmc/rendering/gl/RenderSystemGL.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/gl/RenderSystemGL.h	2023-03-14 17:08:52.446341727 +0100
@@ -73,7 +73,7 @@
   bool BeginRender() override;
   bool EndRender() override;
   void PresentRender(bool rendered, bool videoLayer) override;
-  bool ClearBuffers(UTILS::COLOR::Color color) override;
+  bool ClearBuffers(UTILS::COLOR::Color color, bool forceClearColor, bool forceClearDepth) override;
   bool IsExtSupported(const char* extension) const override;
 
   void SetVSync(bool vsync);
@@ -87,6 +87,8 @@
   void SetScissors(const CRect &rect) override;
   void ResetScissors() override;
 
+  void SetDepthCulling(DEPTH_CULLING culling) override;
+
   void CaptureStateBlock() override;
   void ApplyStateBlock() override;
 
@@ -112,6 +114,7 @@
   GLint ShaderGetCol();
   GLint ShaderGetCoord0();
   GLint ShaderGetCoord1();
+  GLint ShaderGetDepth();
   GLint ShaderGetUniCol();
   GLint ShaderGetModel();
 
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/gles/GLESShader.cpp xbmc-20.1-new/xbmc/rendering/gles/GLESShader.cpp
--- xbmc-20.1-Nexus/xbmc/rendering/gles/GLESShader.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/gles/GLESShader.cpp	2023-03-14 17:08:52.446341727 +0100
@@ -53,6 +53,7 @@
   m_hProj  = glGetUniformLocation(ProgramHandle(), "m_proj");
   m_hModel = glGetUniformLocation(ProgramHandle(), "m_model");
   m_hCoord0Matrix = glGetUniformLocation(ProgramHandle(), "m_coord0Matrix");
+  m_hDepth = glGetUniformLocation(ProgramHandle(), "m_depth");
 
   // Vertex attributes
   m_hPos    = glGetAttribLocation(ProgramHandle(),  "m_attrpos");
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/gles/GLESShader.h xbmc-20.1-new/xbmc/rendering/gles/GLESShader.h
--- xbmc-20.1-Nexus/xbmc/rendering/gles/GLESShader.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/gles/GLESShader.h	2023-03-14 17:08:52.446341727 +0100
@@ -25,6 +25,7 @@
   GLint GetColLoc()   { return m_hCol;   }
   GLint GetCord0Loc() { return m_hCord0; }
   GLint GetCord1Loc() { return m_hCord1; }
+  GLint GetDepthLoc() { return m_hDepth; }
   GLint GetUniColLoc() { return m_hUniCol; }
   GLint GetCoord0MatrixLoc() { return m_hCoord0Matrix; }
   GLint GetFieldLoc() { return m_hField; }
@@ -53,6 +54,7 @@
   GLint m_hStep = 0;
   GLint m_hContrast = 0;
   GLint m_hBrightness = 0;
+  GLint m_hDepth = 0;
 
   const GLfloat *m_proj;
   const GLfloat *m_model;
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/gles/RenderSystemGLES.cpp xbmc-20.1-new/xbmc/rendering/gles/RenderSystemGLES.cpp
--- xbmc-20.1-Nexus/xbmc/rendering/gles/RenderSystemGLES.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/gles/RenderSystemGLES.cpp	2023-03-14 17:08:52.446341727 +0100
@@ -99,6 +99,8 @@
 
   LogGraphicsInfo();
 
+  MatchGPUArchitecture();
+
   m_bRenderCreated = true;
 
   InitialiseShaders();
@@ -184,19 +186,34 @@
   return true;
 }
 
-bool CRenderSystemGLES::ClearBuffers(UTILS::COLOR::Color color)
+bool CRenderSystemGLES::ClearBuffers(UTILS::COLOR::Color color,
+                                     bool forceClearColor,
+                                     bool forceClearDepth)
 {
   if (!m_bRenderCreated)
     return false;
 
-  float r = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::R, color) / 255.0f;
-  float g = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::G, color) / 255.0f;
-  float b = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::B, color) / 255.0f;
-  float a = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::A, color) / 255.0f;
+  GLbitfield flags = 0;
+
+  if (forceClearColor || m_isTileBasedGPU)
+  {
+    float r = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::R, color) / 255.0f;
+    float g = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::G, color) / 255.0f;
+    float b = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::B, color) / 255.0f;
+    float a = KODI::UTILS::GL::GetChannelFromARGB(KODI::UTILS::GL::ColorChannel::A, color) / 255.0f;
+
+    glClearColor(r, g, b, a);
+
+    flags = GL_COLOR_BUFFER_BIT;
+  }
 
-  glClearColor(r, g, b, a);
+  if (forceClearDepth)
+  {
+    flags |= GL_DEPTH_BUFFER_BIT;
+    glClearDepthf(0);
+    glDepthMask(true);
+  }
 
-  GLbitfield flags = GL_COLOR_BUFFER_BIT;
   glClear(flags);
 
   return true;
@@ -380,6 +397,27 @@
   SetScissors(CRect(0, 0, (float)m_width, (float)m_height));
 }
 
+void CRenderSystemGLES::SetDepthCulling(DEPTH_CULLING culling)
+{
+  if (culling == DEPTH_CULLING_OFF)
+  {
+    glDisable(GL_DEPTH_TEST);
+    glDepthMask(GL_FALSE);
+  }
+  else if (culling == DEPTH_CULLING_BACK_TO_FRONT)
+  {
+    glEnable(GL_DEPTH_TEST);
+    glDepthMask(GL_FALSE);
+    glDepthFunc(GL_GEQUAL);
+  }
+  else if (culling == DEPTH_CULLING_FRONT_TO_BACK)
+  {
+    glEnable(GL_DEPTH_TEST);
+    glDepthMask(GL_TRUE);
+    glDepthFunc(GL_GREATER);
+  }
+}
+
 void CRenderSystemGLES::InitialiseShaders()
 {
   std::string defines;
@@ -606,6 +644,14 @@
 
   return -1;
 }
+
+GLint CRenderSystemGLES::ShaderGetDepth()
+{
+  if (m_pShader[m_method])
+    return m_pShader[m_method]->GetDepthLoc();
+
+  return -1;
+}
 
 GLint CRenderSystemGLES::GUIShaderGetUniCol()
 {
diff -ruPN xbmc-20.1-Nexus/xbmc/rendering/gles/RenderSystemGLES.h xbmc-20.1-new/xbmc/rendering/gles/RenderSystemGLES.h
--- xbmc-20.1-Nexus/xbmc/rendering/gles/RenderSystemGLES.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/rendering/gles/RenderSystemGLES.h	2023-03-14 17:08:52.446341727 +0100
@@ -83,7 +83,9 @@
   bool BeginRender() override;
   bool EndRender() override;
   void PresentRender(bool rendered, bool videoLayer) override;
-  bool ClearBuffers(UTILS::COLOR::Color color) override;
+  bool ClearBuffers(UTILS::COLOR::Color color,
+                    bool forceClearColor = true,
+                    bool forceClearDepth = true) override;
   bool IsExtSupported(const char* extension) const override;
 
   void SetVSync(bool vsync);
@@ -97,6 +99,8 @@
   void SetScissors(const CRect& rect) override;
   void ResetScissors() override;
 
+  void SetDepthCulling(DEPTH_CULLING culling) override;
+
   void CaptureStateBlock() override;
   void ApplyStateBlock() override;
 
@@ -124,6 +128,7 @@
   GLint GUIShaderGetContrast();
   GLint GUIShaderGetBrightness();
   GLint GUIShaderGetModel();
+  GLint ShaderGetDepth();
 
 protected:
   virtual void SetVSyncImpl(bool enable) = 0;
diff -ruPN xbmc-20.1-Nexus/xbmc/settings/AdvancedSettings.cpp xbmc-20.1-new/xbmc/settings/AdvancedSettings.cpp
--- xbmc-20.1-Nexus/xbmc/settings/AdvancedSettings.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/settings/AdvancedSettings.cpp	2023-03-14 17:08:52.446341727 +0100
@@ -1243,6 +1243,7 @@
     XMLUtils::GetBoolean(pElement, "visualizedirtyregions", m_guiVisualizeDirtyRegions);
     XMLUtils::GetInt(pElement, "algorithmdirtyregions",     m_guiAlgorithmDirtyRegions);
     XMLUtils::GetBoolean(pElement, "smartredraw", m_guiSmartRedraw);
+    XMLUtils::GetBoolean(pElement, "fronttobackrendering", m_guiFrontToBackRendering);
   }
 
   std::string seekSteps;
diff -ruPN xbmc-20.1-Nexus/xbmc/settings/AdvancedSettings.h xbmc-20.1-new/xbmc/settings/AdvancedSettings.h
--- xbmc-20.1-Nexus/xbmc/settings/AdvancedSettings.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/settings/AdvancedSettings.h	2023-03-14 17:08:52.447341727 +0100
@@ -341,6 +341,7 @@
     bool m_guiVisualizeDirtyRegions;
     int  m_guiAlgorithmDirtyRegions;
     bool m_guiSmartRedraw;
+    bool m_guiFrontToBackRendering{false};
     unsigned int m_addonPackageFolderSize;
 
     unsigned int m_cacheMemSize;
diff -ruPN xbmc-20.1-Nexus/xbmc/utils/TransformMatrix.h xbmc-20.1-new/xbmc/utils/TransformMatrix.h
--- xbmc-20.1-Nexus/xbmc/utils/TransformMatrix.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/utils/TransformMatrix.h	2023-03-14 17:08:52.447341727 +0100
@@ -36,6 +36,7 @@
     m[2][0] = m[2][1] = m[2][3] = 0.0f; m[2][2] = 1.0f;
     alpha = red = green = blue = 1.0f;
     identity = true;
+    depth = 0;
   };
   static TransformMatrix CreateTranslation(float transX, float transY, float transZ = 0)
   {
@@ -50,6 +51,7 @@
     m[2][0] = m[2][1] = 0.0f; m[2][2] = 1.0f; m[2][3] = transZ;
     alpha = red = green = blue = 1.0f;
     identity = (transX == 0 && transY == 0 && transZ == 0);
+    depth = 0;
   }
   static TransformMatrix CreateScaler(float scaleX, float scaleY, float scaleZ = 1.0f)
   {
@@ -69,6 +71,7 @@
     m[2][0] = 0.0f;    m[2][1] = 0.0f;    m[2][2] = scaleZ;  m[2][3] = centerZ*(1-scaleZ);
     alpha = red = green = blue = 1.0f;
     identity = (scaleX == 1 && scaleY == 1);
+    depth = 0;
   };
   void SetXRotation(float angle, float y, float z, float ar = 1.0f)
   { // angle about the X axis, centered at y,z where our coordinate system has aspect ratio ar.
@@ -79,6 +82,7 @@
     m[2][0] = 0.0f;  m[2][1] = s;     m[2][2] = c;      m[2][3] = (-y*s-c*z) + z;
     alpha = red = green = blue = 1.0f;
     identity = (angle == 0);
+    depth = 0;
   }
   void SetYRotation(float angle, float x, float z, float ar = 1.0f)
   { // angle about the Y axis, centered at x,z where our coordinate system has aspect ratio ar.
@@ -89,6 +93,7 @@
     m[2][0] = ar*s;  m[2][1] = 0.0f;  m[2][2] = c;      m[2][3] = -ar*x*s - c*z + z;
     alpha = red = green = blue = 1.0f;
     identity = (angle == 0);
+    depth = 0;
   }
   static TransformMatrix CreateZRotation(float angle, float x, float y, float ar = 1.0f)
   { // angle about the Z axis, centered at x,y where our coordinate system has aspect ratio ar.
@@ -106,6 +111,7 @@
     m[2][0] = 0.0f;  m[2][1] = 0.0f;   m[2][2] = 1.0f;  m[2][3] = 0.0f;
     alpha = red = green = blue = 1.0f;
     identity = (angle == 0);
+    depth = 0;
   }
   static TransformMatrix CreateFader(float a)
   {
@@ -127,6 +133,7 @@
     alpha = a;
     red = green = blue = 1.0f;
     identity = (a == 1.0f);
+    depth = 0;
   }
 
   void SetFader(float a, float r, float g, float b)
@@ -139,6 +146,7 @@
     green = g;
     blue = b;
     identity = ((a == 1.0f) && (r == 1.0f) && (g == 1.0f) && (b == 1.0f));
+    depth = 0;
   }
 
   // multiplication operators
@@ -171,6 +179,7 @@
     green *= right.green;
     blue *= right.blue;
     identity = false;
+    depth = std::max(depth, right.depth);
     return *this;
   }
 
@@ -198,6 +207,7 @@
     result.green = green * right.green;
     result.blue = blue * right.blue;
     result.identity = false;
+    result.depth = std::max(depth, right.depth);
     return result;
   }
 
@@ -278,12 +288,14 @@
   float green;
   float blue;
   bool identity;
+  uint32_t depth{0};
 };
 
 inline bool operator==(const TransformMatrix &a, const TransformMatrix &b)
 {
   bool comparison =
       a.alpha == b.alpha && a.red == b.red && a.green == b.green && a.blue == b.blue &&
+      a.depth == b.depth &&
       ((a.identity && b.identity) ||
        (!a.identity && !b.identity &&
         std::equal(&a.m[0][0], &a.m[0][0] + sizeof(a.m) / sizeof(a.m[0][0]), &b.m[0][0])));
diff -ruPN xbmc-20.1-Nexus/xbmc/video/windows/GUIWindowFullScreen.cpp xbmc-20.1-new/xbmc/video/windows/GUIWindowFullScreen.cpp
--- xbmc-20.1-Nexus/xbmc/video/windows/GUIWindowFullScreen.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/video/windows/GUIWindowFullScreen.cpp	2023-03-14 17:08:52.447341727 +0100
@@ -180,6 +180,8 @@
   const auto appPlayer = components.GetComponent<CApplicationPlayer>();
   if (appPlayer->IsRenderingVideoLayer())
     CServiceBroker::GetWinSystem()->GetGfxContext().Clear(0);
+  else
+    CServiceBroker::GetWinSystem()->GetGfxContext().Clear();
 }
 
 void CGUIWindowFullScreen::OnWindowLoaded()
@@ -374,10 +376,15 @@
 
 void CGUIWindowFullScreen::Render()
 {
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+      RENDER_ORDER_FRONT_TO_BACK)
+    return;
   CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderingResolution(CServiceBroker::GetWinSystem()->GetGfxContext().GetVideoResolution(), false);
   auto& components = CServiceBroker::GetAppComponents();
   const auto appPlayer = components.GetComponent<CApplicationPlayer>();
-  appPlayer->Render(true, 255);
+  // Tilers clear on frame start
+  bool clear = !CServiceBroker::GetWinSystem()->GetRenderSystem()->IsTileBasedGPU();
+  appPlayer->Render(clear, 255);
   CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderingResolution(m_coordsRes, m_needsScaling);
   CGUIWindow::Render();
 }
diff -ruPN xbmc-20.1-Nexus/xbmc/windowing/GraphicContext.cpp xbmc-20.1-new/xbmc/windowing/GraphicContext.cpp
--- xbmc-20.1-Nexus/xbmc/windowing/GraphicContext.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/windowing/GraphicContext.cpp	2023-03-14 17:08:52.447341727 +0100
@@ -580,9 +580,16 @@
   ResetOverscan(res, info.Overscan);
 }
 
+void CGraphicContext::Clear()
+{
+  bool twoPassRendering = m_renderOrder != RENDER_ORDER_ALL_BACK_TO_FRONT;
+  CServiceBroker::GetRenderSystem()->ClearBuffers(0xff000000, false, twoPassRendering);
+}
+
 void CGraphicContext::Clear(UTILS::COLOR::Color color)
 {
-  CServiceBroker::GetRenderSystem()->ClearBuffers(color);
+  bool twoPassRendering = m_renderOrder != RENDER_ORDER_ALL_BACK_TO_FRONT;
+  CServiceBroker::GetRenderSystem()->ClearBuffers(color, true, twoPassRendering);
 }
 
 void CGraphicContext::CaptureStateBlock()
@@ -821,6 +828,14 @@
   UpdateCameraPosition(m_cameras.top(), m_stereoFactors.top());
 }
 
+float CGraphicContext::GetTransformDepth(int32_t depthOffset)
+{
+  float depth = static_cast<float>(m_finalTransform.matrix.depth + depthOffset);
+  depth /= m_layer;
+  depth = depth * 2 - 1;
+  return depth;
+}
+
 CRect CGraphicContext::GenerateAABB(const CRect &rect) const
 {
 // ------------------------
@@ -1005,6 +1020,23 @@
   }
 }
 
+void CGraphicContext::SetRenderOrder(RENDER_ORDER renderOrder)
+{
+  m_renderOrder = renderOrder;
+  if (renderOrder == RENDER_ORDER_ALL_BACK_TO_FRONT)
+    CServiceBroker::GetRenderSystem()->SetDepthCulling(DEPTH_CULLING_OFF);
+  else if (renderOrder == RENDER_ORDER_BACK_TO_FRONT)
+    CServiceBroker::GetRenderSystem()->SetDepthCulling(DEPTH_CULLING_BACK_TO_FRONT);
+  else if (renderOrder == RENDER_ORDER_FRONT_TO_BACK)
+    CServiceBroker::GetRenderSystem()->SetDepthCulling(DEPTH_CULLING_FRONT_TO_BACK);
+}
+
+uint32_t CGraphicContext::GetDepth(uint32_t addLayers)
+{
+  m_layer += addLayers;
+  return m_layer;
+}
+
 void CGraphicContext::SetFPS(float fps)
 {
   m_fFPSOverride = fps;
diff -ruPN xbmc-20.1-Nexus/xbmc/windowing/GraphicContext.cpp.orig xbmc-20.1-new/xbmc/windowing/GraphicContext.cpp.orig
--- xbmc-20.1-Nexus/xbmc/windowing/GraphicContext.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-20.1-new/xbmc/windowing/GraphicContext.cpp.orig	2023-03-11 23:16:38.000000000 +0100
@@ -0,0 +1,1011 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "GraphicContext.h"
+
+#include "ServiceBroker.h"
+#include "WinSystem.h"
+#include "application/ApplicationComponents.h"
+#include "application/ApplicationPlayer.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/TextureManager.h"
+#include "guilib/gui3d.h"
+#include "input/InputManager.h"
+#include "messaging/ApplicationMessenger.h"
+#include "rendering/RenderSystem.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/DisplaySettings.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "settings/lib/Setting.h"
+#include "utils/log.h"
+
+#include <cassert>
+#include <mutex>
+
+CGraphicContext::CGraphicContext() = default;
+CGraphicContext::~CGraphicContext() = default;
+
+void CGraphicContext::SetOrigin(float x, float y)
+{
+  if (!m_origins.empty())
+    m_origins.push(CPoint(x,y) + m_origins.top());
+  else
+    m_origins.push(CPoint(x,y));
+
+  AddTransform(TransformMatrix::CreateTranslation(x, y));
+}
+
+void CGraphicContext::RestoreOrigin()
+{
+  if (!m_origins.empty())
+    m_origins.pop();
+  RemoveTransform();
+}
+
+// add a new clip region, intersecting with the previous clip region.
+bool CGraphicContext::SetClipRegion(float x, float y, float w, float h)
+{ // transform from our origin
+  CPoint origin;
+  if (!m_origins.empty())
+    origin = m_origins.top();
+
+  // ok, now intersect with our old clip region
+  CRect rect(x, y, x + w, y + h);
+  rect += origin;
+  if (!m_clipRegions.empty())
+  {
+    // intersect with original clip region
+    rect.Intersect(m_clipRegions.top());
+  }
+
+  if (rect.IsEmpty())
+    return false;
+
+  m_clipRegions.push(rect);
+
+  // here we could set the hardware clipping, if applicable
+  return true;
+}
+
+void CGraphicContext::RestoreClipRegion()
+{
+  if (!m_clipRegions.empty())
+    m_clipRegions.pop();
+
+  // here we could reset the hardware clipping, if applicable
+}
+
+void CGraphicContext::ClipRect(CRect &vertex, CRect &texture, CRect *texture2)
+{
+  // this is the software clipping routine.  If the graphics hardware is set to do the clipping
+  // (eg via SetClipPlane in D3D for instance) then this routine is unneeded.
+  if (!m_clipRegions.empty())
+  {
+    // take a copy of the vertex rectangle and intersect
+    // it with our clip region (moved to the same coordinate system)
+    CRect clipRegion(m_clipRegions.top());
+    if (!m_origins.empty())
+      clipRegion -= m_origins.top();
+    CRect original(vertex);
+    vertex.Intersect(clipRegion);
+    // and use the original to compute the texture coordinates
+    if (original != vertex)
+    {
+      float scaleX = texture.Width() / original.Width();
+      float scaleY = texture.Height() / original.Height();
+      texture.x1 += (vertex.x1 - original.x1) * scaleX;
+      texture.y1 += (vertex.y1 - original.y1) * scaleY;
+      texture.x2 += (vertex.x2 - original.x2) * scaleX;
+      texture.y2 += (vertex.y2 - original.y2) * scaleY;
+      if (texture2)
+      {
+        scaleX = texture2->Width() / original.Width();
+        scaleY = texture2->Height() / original.Height();
+        texture2->x1 += (vertex.x1 - original.x1) * scaleX;
+        texture2->y1 += (vertex.y1 - original.y1) * scaleY;
+        texture2->x2 += (vertex.x2 - original.x2) * scaleX;
+        texture2->y2 += (vertex.y2 - original.y2) * scaleY;
+      }
+    }
+  }
+}
+
+CRect CGraphicContext::GetClipRegion()
+{
+  if (m_clipRegions.empty())
+    return CRect(0, 0, m_iScreenWidth, m_iScreenHeight);
+  CRect clipRegion(m_clipRegions.top());
+  if (!m_origins.empty())
+    clipRegion -= m_origins.top();
+  return clipRegion;
+}
+
+void CGraphicContext::AddGUITransform()
+{
+  m_transforms.push(m_finalTransform);
+  m_finalTransform = m_guiTransform;
+}
+
+TransformMatrix CGraphicContext::AddTransform(const TransformMatrix &matrix)
+{
+  m_transforms.push(m_finalTransform);
+  m_finalTransform.matrix *= matrix;
+  return m_finalTransform.matrix;
+}
+
+void CGraphicContext::SetTransform(const TransformMatrix &matrix)
+{
+  m_transforms.push(m_finalTransform);
+  m_finalTransform.matrix = matrix;
+}
+
+void CGraphicContext::SetTransform(const TransformMatrix &matrix, float scaleX, float scaleY)
+{
+  m_transforms.push(m_finalTransform);
+  m_finalTransform.matrix = matrix;
+  m_finalTransform.scaleX = scaleX;
+  m_finalTransform.scaleY = scaleY;
+}
+
+void CGraphicContext::RemoveTransform()
+{
+  if (!m_transforms.empty())
+  {
+    m_finalTransform = m_transforms.top();
+    m_transforms.pop();
+  }
+}
+
+bool CGraphicContext::SetViewPort(float fx, float fy, float fwidth, float fheight, bool intersectPrevious /* = false */)
+{
+  // transform coordinates - we may have a rotation which changes the positioning of the
+  // minimal and maximal viewport extents.  We currently go to the maximal extent.
+  float x[4], y[4];
+  x[0] = x[3] = fx;
+  x[1] = x[2] = fx + fwidth;
+  y[0] = y[1] = fy;
+  y[2] = y[3] = fy + fheight;
+  float minX = (float)m_iScreenWidth;
+  float maxX = 0;
+  float minY = (float)m_iScreenHeight;
+  float maxY = 0;
+  for (int i = 0; i < 4; i++)
+  {
+    float z = 0;
+    ScaleFinalCoords(x[i], y[i], z);
+    if (x[i] < minX) minX = x[i];
+    if (x[i] > maxX) maxX = x[i];
+    if (y[i] < minY) minY = y[i];
+    if (y[i] > maxY) maxY = y[i];
+  }
+
+  int newLeft = (int)(minX + 0.5f);
+  int newTop = (int)(minY + 0.5f);
+  int newRight = (int)(maxX + 0.5f);
+  int newBottom = (int)(maxY + 0.5f);
+  if (intersectPrevious)
+  {
+    CRect oldviewport = m_viewStack.top();
+    // do the intersection
+    int oldLeft = (int)oldviewport.x1;
+    int oldTop = (int)oldviewport.y1;
+    int oldRight = (int)oldviewport.x2;
+    int oldBottom = (int)oldviewport.y2;
+    if (newLeft >= oldRight || newTop >= oldBottom || newRight <= oldLeft || newBottom <= oldTop)
+    { // empty intersection - return false to indicate no rendering should occur
+      return false;
+    }
+    // ok, they intersect, do the intersection
+    if (newLeft < oldLeft) newLeft = oldLeft;
+    if (newTop < oldTop) newTop = oldTop;
+    if (newRight > oldRight) newRight = oldRight;
+    if (newBottom > oldBottom) newBottom = oldBottom;
+  }
+  // check range against screen size
+  if (newRight <= 0 || newBottom <= 0 ||
+      newTop >= m_iScreenHeight || newLeft >= m_iScreenWidth ||
+      newLeft >= newRight || newTop >= newBottom)
+  { // no intersection with the screen
+    return false;
+  }
+  // intersection with the screen
+  if (newLeft < 0) newLeft = 0;
+  if (newTop < 0) newTop = 0;
+  if (newRight > m_iScreenWidth) newRight = m_iScreenWidth;
+  if (newBottom > m_iScreenHeight) newBottom = m_iScreenHeight;
+
+  assert(newLeft < newRight);
+  assert(newTop < newBottom);
+
+  CRect newviewport((float)newLeft, (float)newTop, (float)newRight, (float)newBottom);
+
+  m_viewStack.push(newviewport);
+
+  newviewport = StereoCorrection(newviewport);
+  CServiceBroker::GetRenderSystem()->SetViewPort(newviewport);
+
+
+  UpdateCameraPosition(m_cameras.top(), m_stereoFactors.top());
+  return true;
+}
+
+void CGraphicContext::RestoreViewPort()
+{
+  if (m_viewStack.size() <= 1) return;
+
+  m_viewStack.pop();
+  CRect viewport = StereoCorrection(m_viewStack.top());
+  CServiceBroker::GetRenderSystem()->SetViewPort(viewport);
+
+  UpdateCameraPosition(m_cameras.top(), m_stereoFactors.top());
+}
+
+CPoint CGraphicContext::StereoCorrection(const CPoint &point) const
+{
+  CPoint res(point);
+
+  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+  {
+    const RESOLUTION_INFO info = GetResInfo();
+
+    if(m_stereoView == RENDER_STEREO_VIEW_RIGHT)
+      res.y += info.iHeight + info.iBlanking;
+  }
+  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+  {
+    const RESOLUTION_INFO info = GetResInfo();
+
+    if(m_stereoView == RENDER_STEREO_VIEW_RIGHT)
+      res.x += info.iWidth  + info.iBlanking;
+  }
+  return res;
+}
+
+CRect CGraphicContext::StereoCorrection(const CRect &rect) const
+{
+  CRect res(StereoCorrection(rect.P1())
+          , StereoCorrection(rect.P2()));
+  return res;
+}
+
+void CGraphicContext::SetScissors(const CRect &rect)
+{
+  m_scissors = rect;
+  m_scissors.Intersect(CRect(0,0,(float)m_iScreenWidth, (float)m_iScreenHeight));
+  CServiceBroker::GetRenderSystem()->SetScissors(StereoCorrection(m_scissors));
+}
+
+const CRect &CGraphicContext::GetScissors() const
+{
+  return m_scissors;
+}
+
+void CGraphicContext::ResetScissors()
+{
+  m_scissors.SetRect(0, 0, (float)m_iScreenWidth, (float)m_iScreenHeight);
+  CServiceBroker::GetRenderSystem()->SetScissors(StereoCorrection(m_scissors));
+}
+
+const CRect CGraphicContext::GetViewWindow() const
+{
+  if (m_bCalibrating || m_bFullScreenVideo)
+  {
+    CRect rect;
+    RESOLUTION_INFO info = GetResInfo();
+    rect.x1 = (float)info.Overscan.left;
+    rect.y1 = (float)info.Overscan.top;
+    rect.x2 = (float)info.Overscan.right;
+    rect.y2 = (float)info.Overscan.bottom;
+    return rect;
+  }
+  return m_videoRect;
+}
+
+void CGraphicContext::SetViewWindow(float left, float top, float right, float bottom)
+{
+  m_videoRect.x1 = ScaleFinalXCoord(left, top);
+  m_videoRect.y1 = ScaleFinalYCoord(left, top);
+  m_videoRect.x2 = ScaleFinalXCoord(right, bottom);
+  m_videoRect.y2 = ScaleFinalYCoord(right, bottom);
+}
+
+void CGraphicContext::SetFullScreenVideo(bool bOnOff)
+{
+  std::unique_lock<CCriticalSection> lock(*this);
+
+  m_bFullScreenVideo = bOnOff;
+
+  if (m_bFullScreenRoot)
+  {
+    bool bTriggerUpdateRes = false;
+    auto& components = CServiceBroker::GetAppComponents();
+    const auto appPlayer = components.GetComponent<CApplicationPlayer>();
+    if (m_bFullScreenVideo)
+      bTriggerUpdateRes = true;
+    else
+    {
+      bool allowDesktopRes = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_ADJUSTREFRESHRATE) == ADJUST_REFRESHRATE_ALWAYS;
+      if (!allowDesktopRes)
+      {
+        if (appPlayer->IsPlayingVideo())
+          bTriggerUpdateRes = true;
+      }
+    }
+
+    bool allowResolutionChangeOnStop = CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_VIDEOPLAYER_ADJUSTREFRESHRATE) != ADJUST_REFRESHRATE_ON_START;
+    RESOLUTION targetResolutionOnStop = RES_DESKTOP;
+    if (bTriggerUpdateRes)
+      appPlayer->TriggerUpdateResolution();
+    else if (CDisplaySettings::GetInstance().GetCurrentResolution() > RES_DESKTOP)
+    {
+      targetResolutionOnStop = CDisplaySettings::GetInstance().GetCurrentResolution();
+    }
+
+    if (allowResolutionChangeOnStop && !bTriggerUpdateRes)
+    {
+      SetVideoResolution(targetResolutionOnStop, false);
+    }
+  }
+  else
+    SetVideoResolution(RES_WINDOW, false);
+}
+
+bool CGraphicContext::IsFullScreenVideo() const
+{
+  return m_bFullScreenVideo;
+}
+
+bool CGraphicContext::IsCalibrating() const
+{
+  return m_bCalibrating;
+}
+
+void CGraphicContext::SetCalibrating(bool bOnOff)
+{
+  m_bCalibrating = bOnOff;
+}
+
+bool CGraphicContext::IsValidResolution(RESOLUTION res)
+{
+  if (res >= RES_WINDOW && (size_t) res < CDisplaySettings::GetInstance().ResolutionInfoSize())
+  {
+    return true;
+  }
+
+  return false;
+}
+
+// call SetVideoResolutionInternal and ensure its done from mainthread
+void CGraphicContext::SetVideoResolution(RESOLUTION res, bool forceUpdate)
+{
+  if (CServiceBroker::GetAppMessenger()->IsProcessThread())
+  {
+    SetVideoResolutionInternal(res, forceUpdate);
+  }
+  else
+  {
+    CServiceBroker::GetAppMessenger()->SendMsg(TMSG_SETVIDEORESOLUTION, res, forceUpdate ? 1 : 0);
+  }
+}
+
+void CGraphicContext::SetVideoResolutionInternal(RESOLUTION res, bool forceUpdate)
+{
+  RESOLUTION lastRes = m_Resolution;
+
+  // If the user asked us to guess, go with desktop
+  if (!IsValidResolution(res))
+  {
+    res = RES_DESKTOP;
+  }
+
+  // If we are switching to the same resolution and same window/full-screen, no need to do anything
+  if (!forceUpdate && res == lastRes && m_bFullScreenRoot == CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_fullScreen)
+  {
+    return;
+  }
+
+  if (res >= RES_DESKTOP)
+  {
+    CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_fullScreen = true;
+    m_bFullScreenRoot = true;
+  }
+  else
+  {
+    CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_fullScreen = false;
+    m_bFullScreenRoot = false;
+  }
+
+  std::unique_lock<CCriticalSection> lock(*this);
+
+  // FIXME Wayland windowing needs some way to "deny" resolution updates since what Kodi
+  // requests might not get actually set by the compositor.
+  // So in theory, m_iScreenWidth etc. would not need to be updated at all before the
+  // change is confirmed.
+  // But other windowing code expects these variables to be already set when
+  // SetFullScreen() is called, so set them anyway and remember the old values.
+  int origScreenWidth = m_iScreenWidth;
+  int origScreenHeight = m_iScreenHeight;
+  float origFPSOverride = m_fFPSOverride;
+
+  UpdateInternalStateWithResolution(res);
+  RESOLUTION_INFO info_org  = CDisplaySettings::GetInstance().GetResolutionInfo(res);
+
+  bool switched = false;
+  if (CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_fullScreen)
+  {
+#if defined (TARGET_DARWIN) || defined (TARGET_WINDOWS)
+    bool blankOtherDisplays = CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOSCREEN_BLANKDISPLAYS);
+    switched = CServiceBroker::GetWinSystem()->SetFullScreen(true,  info_org, blankOtherDisplays);
+#else
+    switched = CServiceBroker::GetWinSystem()->SetFullScreen(true,  info_org, false);
+#endif
+  }
+  else if (lastRes >= RES_DESKTOP )
+    switched = CServiceBroker::GetWinSystem()->SetFullScreen(false, info_org, false);
+  else
+    switched = CServiceBroker::GetWinSystem()->ResizeWindow(info_org.iWidth, info_org.iHeight, -1, -1);
+
+  if (switched)
+  {
+    m_scissors.SetRect(0, 0, (float)m_iScreenWidth, (float)m_iScreenHeight);
+
+    // make sure all stereo stuff are correctly setup
+    SetStereoView(RENDER_STEREO_VIEW_OFF);
+
+    // update anyone that relies on sizing information
+    CServiceBroker::GetInputManager().SetMouseResolution(info_org.iWidth, info_org.iHeight, 1, 1);
+
+    CGUIComponent *gui = CServiceBroker::GetGUI();
+    if (gui)
+      gui->GetWindowManager().SendMessage(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_WINDOW_RESIZE);
+  }
+  else
+  {
+    // Reset old state
+    m_iScreenWidth = origScreenWidth;
+    m_iScreenHeight = origScreenHeight;
+    m_fFPSOverride = origFPSOverride;
+    if (IsValidResolution(lastRes))
+    {
+      m_Resolution = lastRes;
+    }
+    else
+    {
+      // FIXME Resolution has become invalid
+      // This happens e.g. when switching monitors and the new monitor has fewer
+      // resolutions than the old one. Fall back to RES_DESKTOP and hope that
+      // the real resolution is set soon.
+      // Again, must be fixed as part of a greater refactor.
+      m_Resolution = RES_DESKTOP;
+    }
+  }
+}
+
+void CGraphicContext::ApplyVideoResolution(RESOLUTION res)
+{
+  if (!IsValidResolution(res))
+  {
+    CLog::LogF(LOGWARNING, "Asked to apply invalid resolution {}, falling back to RES_DESKTOP",
+               res);
+    res = RES_DESKTOP;
+  }
+
+  if (res >= RES_DESKTOP)
+  {
+    CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_fullScreen = true;
+    m_bFullScreenRoot = true;
+  }
+  else
+  {
+    CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_fullScreen = false;
+    m_bFullScreenRoot = false;
+  }
+
+  std::unique_lock<CCriticalSection> lock(*this);
+
+  UpdateInternalStateWithResolution(res);
+
+  m_scissors.SetRect(0, 0, (float)m_iScreenWidth, (float)m_iScreenHeight);
+
+  // make sure all stereo stuff are correctly setup
+  SetStereoView(RENDER_STEREO_VIEW_OFF);
+
+  // update anyone that relies on sizing information
+  RESOLUTION_INFO info_org  = CDisplaySettings::GetInstance().GetResolutionInfo(res);
+  CServiceBroker::GetInputManager().SetMouseResolution(info_org.iWidth, info_org.iHeight, 1, 1);
+  CServiceBroker::GetGUI()->GetWindowManager().SendMessage(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_WINDOW_RESIZE);
+}
+
+void CGraphicContext::UpdateInternalStateWithResolution(RESOLUTION res)
+{
+  RESOLUTION_INFO info_mod = GetResInfo(res);
+
+  m_iScreenWidth = info_mod.iWidth;
+  m_iScreenHeight = info_mod.iHeight;
+  m_Resolution = res;
+  m_fFPSOverride = 0;
+}
+
+void CGraphicContext::ApplyModeChange(RESOLUTION res)
+{
+  ApplyVideoResolution(res);
+  CServiceBroker::GetWinSystem()->FinishModeChange(res);
+}
+
+void CGraphicContext::ApplyWindowResize(int newWidth, int newHeight)
+{
+  CServiceBroker::GetWinSystem()->SetWindowResolution(newWidth, newHeight);
+  ApplyVideoResolution(RES_WINDOW);
+  CServiceBroker::GetWinSystem()->FinishWindowResize(newWidth, newHeight);
+}
+
+RESOLUTION CGraphicContext::GetVideoResolution() const
+{
+  return m_Resolution;
+}
+
+void CGraphicContext::ResetOverscan(RESOLUTION_INFO &res)
+{
+  res.Overscan.left = 0;
+  res.Overscan.top = 0;
+  res.Overscan.right = res.iWidth;
+  res.Overscan.bottom = res.iHeight;
+}
+
+void CGraphicContext::ResetOverscan(RESOLUTION res, OVERSCAN &overscan)
+{
+  overscan.left = 0;
+  overscan.top = 0;
+
+  RESOLUTION_INFO info = GetResInfo(res);
+  overscan.right  = info.iWidth;
+  overscan.bottom = info.iHeight;
+}
+
+void CGraphicContext::ResetScreenParameters(RESOLUTION res)
+{
+  RESOLUTION_INFO& info = CDisplaySettings::GetInstance().GetResolutionInfo(res);
+
+  info.iSubtitles = info.iHeight;
+  info.fPixelRatio = 1.0f;
+  info.iScreenWidth = info.iWidth;
+  info.iScreenHeight = info.iHeight;
+  ResetOverscan(res, info.Overscan);
+}
+
+void CGraphicContext::Clear(UTILS::COLOR::Color color)
+{
+  CServiceBroker::GetRenderSystem()->ClearBuffers(color);
+}
+
+void CGraphicContext::CaptureStateBlock()
+{
+  CServiceBroker::GetRenderSystem()->CaptureStateBlock();
+}
+
+void CGraphicContext::ApplyStateBlock()
+{
+  CServiceBroker::GetRenderSystem()->ApplyStateBlock();
+}
+
+const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res) const
+{
+  RESOLUTION_INFO info = CDisplaySettings::GetInstance().GetResolutionInfo(res);
+
+  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+  {
+    if((info.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
+    {
+      info.fPixelRatio     /= 2;
+      info.iBlanking        = 0;
+      info.dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
+    }
+    info.iHeight          = (info.iHeight         - info.iBlanking) / 2;
+    info.Overscan.top    /= 2;
+    info.Overscan.bottom  = (info.Overscan.bottom - info.iBlanking) / 2;
+    info.iSubtitles       = (info.iSubtitles      - info.iBlanking) / 2;
+  }
+
+  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+  {
+    if((info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
+    {
+      info.fPixelRatio     *= 2;
+      info.iBlanking        = 0;
+      info.dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
+    }
+    info.iWidth           = (info.iWidth         - info.iBlanking) / 2;
+    info.Overscan.left   /= 2;
+    info.Overscan.right   = (info.Overscan.right - info.iBlanking) / 2;
+  }
+
+  if (res == m_Resolution && m_fFPSOverride != 0)
+  {
+    info.fRefreshRate = m_fFPSOverride;
+  }
+
+  return info;
+}
+
+void CGraphicContext::SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info)
+{
+  RESOLUTION_INFO& curr = CDisplaySettings::GetInstance().GetResolutionInfo(res);
+  curr.Overscan   = info.Overscan;
+  curr.iSubtitles = info.iSubtitles;
+  curr.fPixelRatio = info.fPixelRatio;
+
+  if(info.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+  {
+    curr.Overscan.right  = info.Overscan.right  * 2 + info.iBlanking;
+    if((curr.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
+      curr.fPixelRatio /= 2.0f;
+  }
+
+  if(info.dwFlags & D3DPRESENTFLAG_MODE3DTB)
+  {
+    curr.Overscan.bottom = info.Overscan.bottom * 2 + info.iBlanking;
+    curr.iSubtitles      = info.iSubtitles      * 2 + info.iBlanking;
+    if((curr.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
+      curr.fPixelRatio *= 2.0f;
+  }
+}
+
+const RESOLUTION_INFO CGraphicContext::GetResInfo() const
+{
+  return GetResInfo(m_Resolution);
+}
+
+void CGraphicContext::GetGUIScaling(const RESOLUTION_INFO &res, float &scaleX, float &scaleY, TransformMatrix *matrix /* = NULL */)
+{
+  if (m_Resolution != RES_INVALID)
+  {
+    // calculate necessary scalings
+    RESOLUTION_INFO info = GetResInfo();
+    float fFromWidth  = (float)res.iWidth;
+    float fFromHeight = (float)res.iHeight;
+    auto fToPosX = info.Overscan.left + info.guiInsets.left;
+    auto fToPosY = info.Overscan.top + info.guiInsets.top;
+    auto fToWidth = info.Overscan.right - info.guiInsets.right - fToPosX;
+    auto fToHeight = info.Overscan.bottom - info.guiInsets.bottom - fToPosY;
+
+    float fZoom = (100 + CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_LOOKANDFEEL_SKINZOOM)) * 0.01f;
+
+    fZoom -= 1.0f;
+    fToPosX -= fToWidth * fZoom * 0.5f;
+    fToWidth *= fZoom + 1.0f;
+
+    // adjust for aspect ratio as zoom is given in the vertical direction and we don't
+    // do aspect ratio corrections in the gui code
+    fZoom = fZoom / info.fPixelRatio;
+    fToPosY -= fToHeight * fZoom * 0.5f;
+    fToHeight *= fZoom + 1.0f;
+
+    scaleX = fFromWidth / fToWidth;
+    scaleY = fFromHeight / fToHeight;
+    if (matrix)
+    {
+      TransformMatrix guiScaler = TransformMatrix::CreateScaler(fToWidth / fFromWidth, fToHeight / fFromHeight, fToHeight / fFromHeight);
+      TransformMatrix guiOffset = TransformMatrix::CreateTranslation(fToPosX, fToPosY);
+      *matrix = guiOffset * guiScaler;
+    }
+  }
+  else
+  {
+    scaleX = scaleY = 1.0f;
+    if (matrix)
+      matrix->Reset();
+  }
+}
+
+void CGraphicContext::SetScalingResolution(const RESOLUTION_INFO &res, bool needsScaling)
+{
+  m_windowResolution = res;
+  if (needsScaling && m_Resolution != RES_INVALID)
+    GetGUIScaling(res, m_guiTransform.scaleX, m_guiTransform.scaleY, &m_guiTransform.matrix);
+  else
+  {
+    m_guiTransform.Reset();
+  }
+
+  // reset our origin and camera
+  while (!m_origins.empty())
+    m_origins.pop();
+  m_origins.push(CPoint(0, 0));
+  while (!m_cameras.empty())
+    m_cameras.pop();
+  m_cameras.push(CPoint(0.5f*m_iScreenWidth, 0.5f*m_iScreenHeight));
+  while (!m_stereoFactors.empty())
+    m_stereoFactors.pop();
+  m_stereoFactors.push(0.0f);
+
+  // and reset the final transform
+  m_finalTransform = m_guiTransform;
+}
+
+void CGraphicContext::SetRenderingResolution(const RESOLUTION_INFO &res, bool needsScaling)
+{
+  std::unique_lock<CCriticalSection> lock(*this);
+
+  SetScalingResolution(res, needsScaling);
+  UpdateCameraPosition(m_cameras.top(), m_stereoFactors.top());
+}
+
+void CGraphicContext::SetStereoView(RENDER_STEREO_VIEW view)
+{
+  m_stereoView = view;
+
+  while(!m_viewStack.empty())
+    m_viewStack.pop();
+
+  CRect viewport(0.0f, 0.0f, (float)m_iScreenWidth, (float)m_iScreenHeight);
+
+  m_viewStack.push(viewport);
+
+  viewport = StereoCorrection(viewport);
+  CServiceBroker::GetRenderSystem()->SetStereoMode(m_stereoMode, m_stereoView);
+  CServiceBroker::GetRenderSystem()->SetViewPort(viewport);
+  CServiceBroker::GetRenderSystem()->SetScissors(viewport);
+}
+
+void CGraphicContext::InvertFinalCoords(float &x, float &y) const
+{
+  m_finalTransform.matrix.InverseTransformPosition(x, y);
+}
+
+float CGraphicContext::ScaleFinalXCoord(float x, float y) const
+{
+  return m_finalTransform.matrix.TransformXCoord(x, y, 0);
+}
+
+float CGraphicContext::ScaleFinalYCoord(float x, float y) const
+{
+  return m_finalTransform.matrix.TransformYCoord(x, y, 0);
+}
+
+float CGraphicContext::ScaleFinalZCoord(float x, float y) const
+{
+  return m_finalTransform.matrix.TransformZCoord(x, y, 0);
+}
+
+void CGraphicContext::ScaleFinalCoords(float &x, float &y, float &z) const
+{
+  m_finalTransform.matrix.TransformPosition(x, y, z);
+}
+
+float CGraphicContext::GetScalingPixelRatio() const
+{
+  // assume the resolutions are different - we want to return the aspect ratio of the video resolution
+  // but only once it's been corrected for the skin -> screen coordinates scaling
+  return GetResInfo().fPixelRatio * (m_finalTransform.scaleY / m_finalTransform.scaleX);
+}
+
+void CGraphicContext::SetCameraPosition(const CPoint &camera)
+{
+  // offset the camera from our current location (this is in XML coordinates) and scale it up to
+  // the screen resolution
+  CPoint cam(camera);
+  if (!m_origins.empty())
+    cam += m_origins.top();
+
+  cam.x *= (float)m_iScreenWidth / m_windowResolution.iWidth;
+  cam.y *= (float)m_iScreenHeight / m_windowResolution.iHeight;
+
+  m_cameras.push(cam);
+  UpdateCameraPosition(m_cameras.top(), m_stereoFactors.top());
+}
+
+void CGraphicContext::RestoreCameraPosition()
+{ // remove the top camera from the stack
+  assert(m_cameras.size());
+  m_cameras.pop();
+  UpdateCameraPosition(m_cameras.top(), m_stereoFactors.top());
+}
+
+void CGraphicContext::SetStereoFactor(float factor)
+{
+  m_stereoFactors.push(factor);
+  UpdateCameraPosition(m_cameras.top(), m_stereoFactors.top());
+}
+
+void CGraphicContext::RestoreStereoFactor()
+{ // remove the top factor from the stack
+  assert(m_stereoFactors.size());
+  m_stereoFactors.pop();
+  UpdateCameraPosition(m_cameras.top(), m_stereoFactors.top());
+}
+
+CRect CGraphicContext::GenerateAABB(const CRect &rect) const
+{
+// ------------------------
+// |(x1, y1)      (x2, y2)|
+// |                      |
+// |(x3, y3)      (x4, y4)|
+// ------------------------
+
+  float x1 = rect.x1, x2 = rect.x2, x3 = rect.x1, x4 = rect.x2;
+  float y1 = rect.y1, y2 = rect.y1, y3 = rect.y2, y4 = rect.y2;
+
+  float z = 0.0f;
+  ScaleFinalCoords(x1, y1, z);
+  CServiceBroker::GetRenderSystem()->Project(x1, y1, z);
+
+  z = 0.0f;
+  ScaleFinalCoords(x2, y2, z);
+  CServiceBroker::GetRenderSystem()->Project(x2, y2, z);
+
+  z = 0.0f;
+  ScaleFinalCoords(x3, y3, z);
+  CServiceBroker::GetRenderSystem()->Project(x3, y3, z);
+
+  z = 0.0f;
+  ScaleFinalCoords(x4, y4, z);
+  CServiceBroker::GetRenderSystem()->Project(x4, y4, z);
+
+  return CRect( std::min(std::min(std::min(x1, x2), x3), x4),
+                std::min(std::min(std::min(y1, y2), y3), y4),
+                std::max(std::max(std::max(x1, x2), x3), x4),
+                std::max(std::max(std::max(y1, y2), y3), y4));
+}
+
+// NOTE: This routine is currently called (twice) every time there is a <camera>
+//       tag in the skin.  It actually only has to be called before we render
+//       something, so another option is to just save the camera coordinates
+//       and then have a routine called before every draw that checks whether
+//       the camera has changed, and if so, changes it.  Similarly, it could set
+//       the world transform at that point as well (or even combine world + view
+//       to cut down on one setting)
+void CGraphicContext::UpdateCameraPosition(const CPoint &camera, const float &factor)
+{
+  float stereoFactor = 0.f;
+  if ( m_stereoMode != RENDER_STEREO_MODE_OFF
+    && m_stereoMode != RENDER_STEREO_MODE_MONO
+    && m_stereoView != RENDER_STEREO_VIEW_OFF)
+  {
+    RESOLUTION_INFO res = GetResInfo();
+    RESOLUTION_INFO desktop = GetResInfo(RES_DESKTOP);
+    float scaleRes = (static_cast<float>(res.iWidth) / static_cast<float>(desktop.iWidth));
+    float scaleX = static_cast<float>(CServiceBroker::GetSettingsComponent()->GetSettings()->GetInt(CSettings::SETTING_LOOKANDFEEL_STEREOSTRENGTH)) * scaleRes;
+    stereoFactor = factor * (m_stereoView == RENDER_STEREO_VIEW_LEFT ? scaleX : -scaleX);
+  }
+  CServiceBroker::GetRenderSystem()->SetCameraPosition(camera, m_iScreenWidth, m_iScreenHeight, stereoFactor);
+}
+
+bool CGraphicContext::RectIsAngled(float x1, float y1, float x2, float y2) const
+{ // need only test 3 points, as they must be co-planer
+  if (m_finalTransform.matrix.TransformZCoord(x1, y1, 0)) return true;
+  if (m_finalTransform.matrix.TransformZCoord(x2, y2, 0)) return true;
+  if (m_finalTransform.matrix.TransformZCoord(x1, y2, 0)) return true;
+  return false;
+}
+
+const TransformMatrix &CGraphicContext::GetGUIMatrix() const
+{
+  return m_finalTransform.matrix;
+}
+
+float CGraphicContext::GetGUIScaleX() const
+{
+  return m_finalTransform.scaleX;
+}
+
+float CGraphicContext::GetGUIScaleY() const
+{
+  return m_finalTransform.scaleY;
+}
+
+UTILS::COLOR::Color CGraphicContext::MergeAlpha(UTILS::COLOR::Color color) const
+{
+  UTILS::COLOR::Color alpha = m_finalTransform.matrix.TransformAlpha((color >> 24) & 0xff);
+  if (alpha > 255) alpha = 255;
+  return ((alpha << 24) & 0xff000000) | (color & 0xffffff);
+}
+
+UTILS::COLOR::Color CGraphicContext::MergeColor(UTILS::COLOR::Color color) const
+{
+  return m_finalTransform.matrix.TransformColor(color);
+}
+
+int CGraphicContext::GetWidth() const
+{
+  return m_iScreenWidth;
+}
+
+int CGraphicContext::GetHeight() const
+{
+  return m_iScreenHeight;
+}
+
+float CGraphicContext::GetFPS() const
+{
+  if (m_Resolution != RES_INVALID)
+  {
+    RESOLUTION_INFO info = GetResInfo();
+    if (info.fRefreshRate > 0)
+      return info.fRefreshRate;
+  }
+  return 60.0f;
+}
+
+float CGraphicContext::GetDisplayLatency() const
+{
+  float latency = CServiceBroker::GetWinSystem()->GetDisplayLatency();
+  if (latency < 0.0f)
+  {
+    // fallback
+    latency = (CServiceBroker::GetWinSystem()->NoOfBuffers() + 1) / GetFPS() * 1000.0f;
+  }
+
+  return latency;
+}
+
+bool CGraphicContext::IsFullScreenRoot () const
+{
+  return m_bFullScreenRoot;
+}
+
+void CGraphicContext::ToggleFullScreen()
+{
+  RESOLUTION uiRes;
+
+  if (m_bFullScreenRoot)
+  {
+    uiRes = RES_WINDOW;
+  }
+  else
+  {
+    if (CDisplaySettings::GetInstance().GetCurrentResolution() > RES_DESKTOP)
+      uiRes = CDisplaySettings::GetInstance().GetCurrentResolution();
+    else
+      uiRes = RES_DESKTOP;
+  }
+
+  CDisplaySettings::GetInstance().SetCurrentResolution(uiRes, true);
+}
+
+void CGraphicContext::SetMediaDir(const std::string &strMediaDir)
+{
+  CServiceBroker::GetGUI()->GetTextureManager().SetTexturePath(strMediaDir);
+  m_strMediaDir = strMediaDir;
+}
+
+const std::string& CGraphicContext::GetMediaDir() const
+{
+  return m_strMediaDir;
+
+}
+
+void CGraphicContext::Flip(bool rendered, bool videoLayer)
+{
+  CServiceBroker::GetRenderSystem()->PresentRender(rendered, videoLayer);
+
+  if(m_stereoMode != m_nextStereoMode)
+  {
+    m_stereoMode = m_nextStereoMode;
+    SetVideoResolution(GetVideoResolution(), true);
+    CServiceBroker::GetGUI()->GetWindowManager().SendMessage(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_RENDERER_RESET);
+  }
+}
+
+void CGraphicContext::GetAllowedResolutions(std::vector<RESOLUTION> &res)
+{
+  res.clear();
+
+  res.push_back(RES_WINDOW);
+  res.push_back(RES_DESKTOP);
+  for (size_t r = (size_t) RES_CUSTOM; r < CDisplaySettings::GetInstance().ResolutionInfoSize(); r++)
+  {
+    res.push_back((RESOLUTION) r);
+  }
+}
+
+void CGraphicContext::SetFPS(float fps)
+{
+  m_fFPSOverride = fps;
+}
diff -ruPN xbmc-20.1-Nexus/xbmc/windowing/GraphicContext.h xbmc-20.1-new/xbmc/windowing/GraphicContext.h
--- xbmc-20.1-Nexus/xbmc/windowing/GraphicContext.h	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/windowing/GraphicContext.h	2023-03-14 17:08:52.447341727 +0100
@@ -57,6 +57,13 @@
   ADJUST_REFRESHRATE_ON_START,
 };
 
+enum RENDER_ORDER
+{
+  RENDER_ORDER_ALL_BACK_TO_FRONT = 0,
+  RENDER_ORDER_BACK_TO_FRONT,
+  RENDER_ORDER_FRONT_TO_BACK,
+};
+
 class CGraphicContext : public CCriticalSection
 {
 public:
@@ -99,8 +106,25 @@
   void ResetScreenParameters(RESOLUTION res);
   void CaptureStateBlock();
   void ApplyStateBlock();
-  void Clear(UTILS::COLOR::Color color = 0);
+  /*! \brief Clears the depth buffer (if used) and the color buffer on tiling
+   GPUs. Will result in undefined color buffer values which will have to be
+   repainted. Has to be called at the beginning of a frame.
+   */
+  void Clear();
+  /*! \brief Clears the depth buffer (if used) and the color buffer. Guaranties
+   a defined frame buffer value. Has to be called at the beginning of a frame.
+   \param color the specified color.
+   */
+  void Clear(UTILS::COLOR::Color color);
   void GetAllowedResolutions(std::vector<RESOLUTION> &res);
+  void SetRenderOrder(RENDER_ORDER renderOrder);
+  RENDER_ORDER GetRenderOrder() { return m_renderOrder; }
+  void ResetDepth() { m_layer = 2; }
+  /*! \brief Adds layers for the caller to use
+   \param addLayers number of layers needed
+   \returns uint32_t returns the absolute layer hight
+   */
+  uint32_t GetDepth(uint32_t addLayers = 2);
 
   /* \brief Get UI scaling information from a given resolution to the screen resolution.
    Takes account of overscan and UI zooming.
@@ -134,6 +158,11 @@
   void RestoreCameraPosition();
   void SetStereoFactor(float factor);
   void RestoreStereoFactor();
+  /*! \brief Gets the depth information of the current transform matrix
+   \param depthOffset adds an offset to the current depth
+   \returns float normalized -1 to 1
+   */
+  float GetTransformDepth(int32_t depthOffset = 0);
   /*! \brief Set a region in which to clip all rendering
    Anything that is rendered after setting a clip region will be clipped so that no part renders
    outside of the clip region.  Successive calls to SetClipRegion intersect the clip region, which
@@ -229,4 +258,6 @@
   RENDER_STEREO_VIEW m_stereoView = RENDER_STEREO_VIEW_OFF;
   RENDER_STEREO_MODE m_stereoMode = RENDER_STEREO_MODE_OFF;
   RENDER_STEREO_MODE m_nextStereoMode = RENDER_STEREO_MODE_OFF;
+  RENDER_ORDER m_renderOrder{RENDER_ORDER_ALL_BACK_TO_FRONT};
+  uint32_t m_layer{2};
 };
diff -ruPN xbmc-20.1-Nexus/xbmc/windowing/X11/GLContextEGL.cpp xbmc-20.1-new/xbmc/windowing/X11/GLContextEGL.cpp
--- xbmc-20.1-Nexus/xbmc/windowing/X11/GLContextEGL.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/windowing/X11/GLContextEGL.cpp	2023-03-14 17:08:52.447341727 +0100
@@ -340,7 +340,7 @@
     return false;
   if (!eglGetConfigAttrib(eglDisplay, config, EGL_BLUE_SIZE, &value) || value < 8)
     return false;
-  if (!eglGetConfigAttrib(eglDisplay, config, EGL_DEPTH_SIZE, &value) || value < 24)
+  if (!eglGetConfigAttrib(eglDisplay, config, EGL_DEPTH_SIZE, &value) || value < 16)
     return false;
 
   return true;
diff -ruPN xbmc-20.1-Nexus/xbmc/windowing/X11/GLContextEGL.cpp.orig xbmc-20.1-new/xbmc/windowing/X11/GLContextEGL.cpp.orig
--- xbmc-20.1-Nexus/xbmc/windowing/X11/GLContextEGL.cpp.orig	1970-01-01 01:00:00.000000000 +0100
+++ xbmc-20.1-new/xbmc/windowing/X11/GLContextEGL.cpp.orig	2023-03-11 23:16:38.000000000 +0100
@@ -0,0 +1,542 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+// always define GL_GLEXT_PROTOTYPES before include gl headers
+#if !defined(GL_GLEXT_PROTOTYPES)
+  #define GL_GLEXT_PROTOTYPES
+#endif
+
+#include "GLContextEGL.h"
+
+#include "ServiceBroker.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/SettingsComponent.h"
+#include "utils/log.h"
+
+#include <clocale>
+#include <mutex>
+
+#include <EGL/eglext.h>
+#include <unistd.h>
+
+#include "PlatformDefs.h"
+#include "system_gl.h"
+
+#define EGL_NO_CONFIG (EGLConfig)0
+
+CGLContextEGL::CGLContextEGL(Display* dpy, EGLint renderingApi)
+  : CGLContext(dpy), m_renderingApi(renderingApi)
+{
+  m_extPrefix = "EGL_";
+  m_eglConfig = EGL_NO_CONFIG;
+
+  m_eglGetPlatformDisplayEXT = (PFNEGLGETPLATFORMDISPLAYEXTPROC)eglGetProcAddress("eglGetPlatformDisplayEXT");
+
+  const auto settings = CServiceBroker::GetSettingsComponent();
+  if (settings)
+  {
+    m_omlSync = settings->GetAdvancedSettings()->m_omlSync;
+  }
+}
+
+CGLContextEGL::~CGLContextEGL()
+{
+  Destroy();
+}
+
+bool CGLContextEGL::Refresh(bool force, int screen, Window glWindow, bool &newContext)
+{
+  m_sync.cont = 0;
+
+  // refresh context
+  if (m_eglContext && !force)
+  {
+    if (m_eglSurface == EGL_NO_SURFACE)
+    {
+      m_eglSurface = eglCreateWindowSurface(m_eglDisplay, m_eglConfig, glWindow, NULL);
+      if (m_eglSurface == EGL_NO_SURFACE)
+      {
+        CLog::Log(LOGERROR, "failed to create EGL window surface {}", eglGetError());
+        return false;
+      }
+    }
+
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshEGLContext: refreshing context");
+    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext);
+    return true;
+  }
+
+  Destroy();
+  newContext = true;
+
+  if (m_eglGetPlatformDisplayEXT)
+  {
+    EGLint attribs[] =
+    {
+      EGL_PLATFORM_X11_SCREEN_EXT, screen,
+      EGL_NONE
+    };
+    m_eglDisplay = m_eglGetPlatformDisplayEXT(EGL_PLATFORM_X11_EXT,(EGLNativeDisplayType)m_dpy,
+                                            attribs);
+  }
+  else
+    m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
+
+  if (m_eglDisplay == EGL_NO_DISPLAY)
+  {
+    CLog::Log(LOGERROR, "failed to get egl display");
+    return false;
+  }
+  if (!eglInitialize(m_eglDisplay, NULL, NULL))
+  {
+    CLog::Log(LOGERROR, "failed to initialize egl");
+    Destroy();
+    return false;
+  }
+  if (!eglBindAPI(m_renderingApi))
+  {
+    CLog::Log(LOGERROR, "failed to bind rendering API");
+    Destroy();
+    return false;
+  }
+
+  // create context
+
+  XVisualInfo vMask;
+  XVisualInfo *vInfo = nullptr;
+  int availableVisuals    = 0;
+  vMask.screen = screen;
+  XWindowAttributes winAttr;
+
+  if (!XGetWindowAttributes(m_dpy, glWindow, &winAttr))
+  {
+    CLog::Log(LOGWARNING, "Failed to get window attributes");
+    Destroy();
+    return false;
+  }
+
+  vMask.visualid = XVisualIDFromVisual(winAttr.visual);
+  vInfo = XGetVisualInfo(m_dpy, VisualScreenMask | VisualIDMask, &vMask, &availableVisuals);
+  if (!vInfo)
+  {
+    CLog::Log(LOGERROR, "Failed to get VisualInfo of visual 0x{:x}", (unsigned)vMask.visualid);
+    Destroy();
+    return false;
+  }
+
+  unsigned int visualid = static_cast<unsigned int>(vInfo->visualid);
+  m_eglConfig = GetEGLConfig(m_eglDisplay, vInfo);
+  XFree(vInfo);
+
+  if (m_eglConfig == EGL_NO_CONFIG)
+  {
+    CLog::Log(LOGERROR, "failed to get suitable eglconfig for visual 0x{:x}", visualid);
+    Destroy();
+    return false;
+  }
+
+  CLog::Log(LOGINFO, "Using visual 0x{:x}", visualid);
+
+  m_eglSurface = eglCreateWindowSurface(m_eglDisplay, m_eglConfig, glWindow, NULL);
+  if (m_eglSurface == EGL_NO_SURFACE)
+  {
+    CLog::Log(LOGERROR, "failed to create EGL window surface {}", eglGetError());
+    Destroy();
+    return false;
+  }
+
+  EGLint contextAttributes[] =
+  {
+      EGL_CONTEXT_MAJOR_VERSION_KHR, 3,
+      EGL_CONTEXT_MINOR_VERSION_KHR, 2,
+      EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR, EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR,
+      EGL_NONE
+  };
+  m_eglContext = eglCreateContext(m_eglDisplay, m_eglConfig, EGL_NO_CONTEXT, contextAttributes);
+  if (m_eglContext == EGL_NO_CONTEXT)
+  {
+    EGLint contextAttributes[] =
+    {
+      EGL_CONTEXT_MAJOR_VERSION_KHR, 2,
+      EGL_NONE
+    };
+    m_eglContext = eglCreateContext(m_eglDisplay, m_eglConfig, EGL_NO_CONTEXT, contextAttributes);
+
+    if (m_eglContext == EGL_NO_CONTEXT)
+    {
+      CLog::Log(LOGERROR, "failed to create EGL context");
+      Destroy();
+      return false;
+    }
+
+    CLog::Log(LOGWARNING, "Failed to get an OpenGL context supporting core profile 3.2, "
+                          "using legacy mode with reduced feature set");
+  }
+
+  if (!eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext))
+  {
+    CLog::Log(LOGERROR, "Failed to make context current {} {} {}", fmt::ptr(m_eglDisplay),
+              fmt::ptr(m_eglSurface), fmt::ptr(m_eglContext));
+    Destroy();
+    return false;
+  }
+
+  m_eglGetSyncValuesCHROMIUM = (PFNEGLGETSYNCVALUESCHROMIUMPROC)eglGetProcAddress("eglGetSyncValuesCHROMIUM");
+
+  m_usePB = false;
+  return true;
+}
+
+bool CGLContextEGL::CreatePB()
+{
+  const EGLint configAttribs[] =
+  {
+    EGL_SURFACE_TYPE, EGL_PBUFFER_BIT,
+    EGL_BLUE_SIZE, 8,
+    EGL_GREEN_SIZE, 8,
+    EGL_RED_SIZE, 8,
+    EGL_DEPTH_SIZE, 8,
+    EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
+    EGL_NONE
+  };
+
+  const EGLint pbufferAttribs[] =
+  {
+    EGL_WIDTH, 9,
+    EGL_HEIGHT, 9,
+    EGL_NONE,
+  };
+
+  Destroy();
+
+  if (m_eglGetPlatformDisplayEXT)
+  {
+    m_eglDisplay = m_eglGetPlatformDisplayEXT(EGL_PLATFORM_X11_EXT,(EGLNativeDisplayType)m_dpy,
+                                            NULL);
+  }
+  else
+    m_eglDisplay = eglGetDisplay((EGLNativeDisplayType)m_dpy);
+
+  if (m_eglDisplay == EGL_NO_DISPLAY)
+  {
+    CLog::Log(LOGERROR, "failed to get egl display");
+    return false;
+  }
+  if (!eglInitialize(m_eglDisplay, NULL, NULL))
+  {
+    CLog::Log(LOGERROR, "failed to initialize egl");
+    Destroy();
+    return false;
+  }
+  if (!eglBindAPI(m_renderingApi))
+  {
+    CLog::Log(LOGERROR, "failed to bind rendering API");
+    Destroy();
+    return false;
+  }
+
+  EGLint numConfigs;
+
+  eglChooseConfig(m_eglDisplay, configAttribs, &m_eglConfig, 1, &numConfigs);
+  m_eglSurface = eglCreatePbufferSurface(m_eglDisplay, m_eglConfig, pbufferAttribs);
+  if (m_eglSurface == EGL_NO_SURFACE)
+  {
+    CLog::Log(LOGERROR, "failed to create EGL window surface {}", eglGetError());
+    Destroy();
+    return false;
+  }
+
+  EGLint contextAttributes[] =
+  {
+      EGL_CONTEXT_MAJOR_VERSION_KHR, 3,
+      EGL_CONTEXT_MINOR_VERSION_KHR, 2,
+      EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR, EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT_KHR,
+      EGL_NONE
+  };
+  m_eglContext = eglCreateContext(m_eglDisplay, m_eglConfig, EGL_NO_CONTEXT, contextAttributes);
+  if (m_eglContext == EGL_NO_CONTEXT)
+  {
+    EGLint contextAttributes[] =
+    {
+      EGL_CONTEXT_MAJOR_VERSION_KHR, 2,
+      EGL_NONE
+    };
+    m_eglContext = eglCreateContext(m_eglDisplay, m_eglConfig, EGL_NO_CONTEXT, contextAttributes);
+
+    if (m_eglContext == EGL_NO_CONTEXT)
+    {
+      CLog::Log(LOGERROR, "failed to create EGL context");
+      Destroy();
+      return false;
+    }
+  }
+
+  if (!eglMakeCurrent(m_eglDisplay, m_eglSurface, m_eglSurface, m_eglContext))
+  {
+    CLog::Log(LOGERROR, "Failed to make context current {} {} {}", fmt::ptr(m_eglDisplay),
+              fmt::ptr(m_eglSurface), fmt::ptr(m_eglContext));
+    Destroy();
+    return false;
+  }
+
+  m_usePB = true;
+  return true;
+}
+
+void CGLContextEGL::Destroy()
+{
+  if (m_eglContext)
+  {
+    glFinish();
+    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    eglDestroyContext(m_eglDisplay, m_eglContext);
+    m_eglContext = EGL_NO_CONTEXT;
+  }
+
+  if (m_eglSurface)
+  {
+    eglDestroySurface(m_eglDisplay, m_eglSurface);
+    m_eglSurface = EGL_NO_SURFACE;
+  }
+
+  if (m_eglDisplay)
+  {
+    eglTerminate(m_eglDisplay);
+    m_eglDisplay = EGL_NO_DISPLAY;
+  }
+
+  m_eglConfig = EGL_NO_CONFIG;
+}
+
+void CGLContextEGL::Detach()
+{
+  if (m_eglContext)
+  {
+    glFinish();
+    eglMakeCurrent(m_eglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+  }
+  if (m_eglSurface)
+  {
+    eglDestroySurface(m_eglDisplay, m_eglSurface);
+    m_eglSurface = EGL_NO_SURFACE;
+  }
+}
+
+bool CGLContextEGL::SuitableCheck(EGLDisplay eglDisplay, EGLConfig config)
+{
+  if (config == EGL_NO_CONFIG)
+    return false;
+
+  EGLint value;
+  if (!eglGetConfigAttrib(eglDisplay, config, EGL_RED_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(eglDisplay, config, EGL_GREEN_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(eglDisplay, config, EGL_BLUE_SIZE, &value) || value < 8)
+    return false;
+  if (!eglGetConfigAttrib(eglDisplay, config, EGL_DEPTH_SIZE, &value) || value < 24)
+    return false;
+
+  return true;
+}
+
+EGLConfig CGLContextEGL::GetEGLConfig(EGLDisplay eglDisplay, XVisualInfo *vInfo)
+{
+  EGLint numConfigs;
+
+  if (!eglGetConfigs(eglDisplay, nullptr, 0, &numConfigs))
+  {
+    CLog::Log(LOGERROR, "Failed to query number of egl configs");
+    return EGL_NO_CONFIG;
+  }
+  if (numConfigs == 0)
+  {
+    CLog::Log(LOGERROR, "No suitable egl configs found");
+    return EGL_NO_CONFIG;
+  }
+
+  EGLConfig *eglConfigs;
+  eglConfigs = (EGLConfig*)malloc(numConfigs * sizeof(EGLConfig));
+  if (!eglConfigs)
+  {
+    CLog::Log(LOGERROR, "eglConfigs malloc failed");
+    return EGL_NO_CONFIG;
+  }
+  EGLConfig eglConfig = EGL_NO_CONFIG;
+  if (!eglGetConfigs(eglDisplay, eglConfigs, numConfigs, &numConfigs))
+  {
+    CLog::Log(LOGERROR, "Failed to query egl configs");
+    goto Exit;
+  }
+  for (EGLint i = 0; i < numConfigs; ++i)
+  {
+    if (!SuitableCheck(eglDisplay, eglConfigs[i]))
+      continue;
+
+    EGLint value;
+    if (!eglGetConfigAttrib(eglDisplay, eglConfigs[i], EGL_NATIVE_VISUAL_ID, &value))
+    {
+      CLog::Log(LOGERROR, "Failed to query EGL_NATIVE_VISUAL_ID for egl config.");
+      break;
+    }
+    if (value == (EGLint)vInfo->visualid)
+    {
+      eglConfig = eglConfigs[i];
+      break;
+    }
+  }
+
+Exit:
+  free(eglConfigs);
+  return eglConfig;
+}
+
+void CGLContextEGL::SetVSync(bool enable)
+{
+  eglSwapInterval(m_eglDisplay, enable ? 1 : 0);
+}
+
+void CGLContextEGL::SwapBuffers()
+{
+  if ((m_eglDisplay == EGL_NO_DISPLAY) || (m_eglSurface == EGL_NO_SURFACE))
+    return;
+
+  if (m_usePB)
+  {
+    eglSwapBuffers(m_eglDisplay, m_eglSurface);
+    usleep(20 * 1000);
+    return;
+  }
+
+  uint64_t ust1, ust2;
+  uint64_t msc1, msc2;
+  uint64_t sbc1, sbc2;
+  struct timespec nowTs;
+  uint64_t now;
+  uint64_t cont = m_sync.cont;
+  uint64_t interval = m_sync.interval;
+
+  if (m_eglGetSyncValuesCHROMIUM)
+  {
+    m_eglGetSyncValuesCHROMIUM(m_eglDisplay, m_eglSurface, &ust1, &msc1, &sbc1);
+  }
+
+  eglSwapBuffers(m_eglDisplay, m_eglSurface);
+
+  if (!m_eglGetSyncValuesCHROMIUM)
+    return;
+
+  clock_gettime(CLOCK_MONOTONIC, &nowTs);
+  now = static_cast<uint64_t>(nowTs.tv_sec) * 1000000000ULL + nowTs.tv_nsec;
+
+  m_eglGetSyncValuesCHROMIUM(m_eglDisplay, m_eglSurface, &ust2, &msc2, &sbc2);
+
+  if ((msc1 - m_sync.msc1) > 2)
+  {
+    cont = 0;
+  }
+
+  // we want to block in SwapBuffers
+  // if a vertical retrace occurs 5 times in a row outside
+  // of this function, we take action
+  if (m_sync.cont < 5)
+  {
+    if ((msc1 - m_sync.msc1) == 2)
+    {
+      cont = 0;
+    }
+    else if ((msc1 - m_sync.msc1) == 1)
+    {
+      interval = (ust1 - m_sync.ust1) / (msc1 - m_sync.msc1);
+      cont++;
+    }
+  }
+  else if (m_sync.cont == 5 && m_omlSync)
+  {
+    CLog::Log(LOGDEBUG, "CGLContextEGL::SwapBuffers: sync check blocking");
+
+    if (msc2 == msc1)
+    {
+      // if no vertical retrace has occurred in eglSwapBuffers,
+      // sleep until next vertical retrace
+      uint64_t lastIncrement = (now / 1000 - ust2);
+      if (lastIncrement > m_sync.interval)
+      {
+        lastIncrement = m_sync.interval;
+        CLog::Log(LOGWARNING, "CGLContextEGL::SwapBuffers: last msc time greater than interval");
+      }
+      uint64_t sleeptime = m_sync.interval - lastIncrement;
+      usleep(sleeptime);
+      cont++;
+      msc2++;
+      CLog::Log(LOGDEBUG, "CGLContextEGL::SwapBuffers: sync sleep: {}", sleeptime);
+    }
+  }
+  else if ((m_sync.cont > 5) && (msc2 == m_sync.msc2))
+  {
+    // sleep until next vertical retrace
+    // this avoids blocking outside of this function
+    uint64_t lastIncrement = (now / 1000 - ust2);
+    if (lastIncrement > m_sync.interval)
+    {
+      lastIncrement = m_sync.interval;
+      CLog::Log(LOGWARNING, "CGLContextEGL::SwapBuffers: last msc time greater than interval (1)");
+    }
+    uint64_t sleeptime = m_sync.interval - lastIncrement;
+    usleep(sleeptime);
+    msc2++;
+  }
+  {
+    std::unique_lock<CCriticalSection> lock(m_syncLock);
+    m_sync.ust1 = ust1;
+    m_sync.ust2 = ust2;
+    m_sync.msc1 = msc1;
+    m_sync.msc2 = msc2;
+    m_sync.interval = interval;
+    m_sync.cont = cont;
+  }
+}
+
+uint64_t CGLContextEGL::GetVblankTiming(uint64_t &msc, uint64_t &interval)
+{
+  struct timespec nowTs;
+  uint64_t now;
+  clock_gettime(CLOCK_MONOTONIC, &nowTs);
+  now = static_cast<uint64_t>(nowTs.tv_sec) * 1000000000ULL + nowTs.tv_nsec;
+  now /= 1000;
+
+  std::unique_lock<CCriticalSection> lock(m_syncLock);
+  msc = m_sync.msc2;
+
+  interval = (m_sync.cont >= 5) ? m_sync.interval : m_sync.ust2 - m_sync.ust1;
+  if (interval == 0)
+    return 0;
+
+  if (now < m_sync.ust2)
+  {
+    return 0;
+  }
+
+  uint64_t ret = now - m_sync.ust2;
+  while (ret > interval)
+  {
+    ret -= interval;
+    msc++;
+  }
+
+  return ret;
+}
+
+void CGLContextEGL::QueryExtensions()
+{
+  std::string extensions = eglQueryString(m_eglDisplay, EGL_EXTENSIONS);
+  m_extensions = std::string(" ") + extensions + " ";
+
+  CLog::Log(LOGDEBUG, "EGL_EXTENSIONS:{}", m_extensions);
+}
diff -ruPN xbmc-20.1-Nexus/xbmc/windows/GUIWindowDebugInfo.cpp xbmc-20.1-new/xbmc/windows/GUIWindowDebugInfo.cpp
--- xbmc-20.1-Nexus/xbmc/windows/GUIWindowDebugInfo.cpp	2023-03-11 23:16:38.000000000 +0100
+++ xbmc-20.1-new/xbmc/windows/GUIWindowDebugInfo.cpp	2023-03-14 17:08:52.447341727 +0100
@@ -179,7 +179,13 @@
 
 void CGUIWindowDebugInfo::Render()
 {
+  RENDER_ORDER renderOrder = CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder();
+  if (renderOrder == RENDER_ORDER_FRONT_TO_BACK)
+    return;
+  else if (renderOrder == RENDER_ORDER_BACK_TO_FRONT)
+    CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderOrder(RENDER_ORDER_ALL_BACK_TO_FRONT);
   CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderingResolution(CServiceBroker::GetWinSystem()->GetGfxContext().GetResInfo(), false);
   if (m_layout)
     m_layout->RenderOutline(m_renderRegion.x1, m_renderRegion.y1, 0xffffffff, 0xff000000, 0, 0);
+  CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderOrder(renderOrder);
 }

From 1b8968e6456bd07d28cfac8fde623e37fcfcd119 Mon Sep 17 00:00:00 2001
From: sarbes <sarbes@kodi.tv>
Date: Thu, 16 Mar 2023 20:16:03 +0100
Subject: [PATCH] Display opaque elements of the fullscreen window

---
 xbmc/video/windows/GUIWindowFullScreen.cpp | 21 ++++++++++++---------
 1 file changed, 12 insertions(+), 9 deletions(-)

diff --git a/xbmc/video/windows/GUIWindowFullScreen.cpp b/xbmc/video/windows/GUIWindowFullScreen.cpp
index 2a89a536a38ac..cb66a5c6a829d 100644
--- a/xbmc/video/windows/GUIWindowFullScreen.cpp
+++ b/xbmc/video/windows/GUIWindowFullScreen.cpp
@@ -376,16 +376,19 @@ void CGUIWindowFullScreen::Process(unsigned int currentTime, CDirtyRegionList &d
 
 void CGUIWindowFullScreen::Render()
 {
-  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() ==
+  if (CServiceBroker::GetWinSystem()->GetGfxContext().GetRenderOrder() !=
       RENDER_ORDER_FRONT_TO_BACK)
-    return;
-  CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderingResolution(CServiceBroker::GetWinSystem()->GetGfxContext().GetVideoResolution(), false);
-  auto& components = CServiceBroker::GetAppComponents();
-  const auto appPlayer = components.GetComponent<CApplicationPlayer>();
-  // Tilers clear on frame start
-  bool clear = !CServiceBroker::GetWinSystem()->GetRenderSystem()->IsTileBasedGPU();
-  appPlayer->Render(clear, 255);
-  CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderingResolution(m_coordsRes, m_needsScaling);
+  {
+    CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderingResolution(
+        CServiceBroker::GetWinSystem()->GetGfxContext().GetVideoResolution(), false);
+    auto& components = CServiceBroker::GetAppComponents();
+    const auto appPlayer = components.GetComponent<CApplicationPlayer>();
+    // Tilers clear on frame start
+    bool clear = !CServiceBroker::GetWinSystem()->GetRenderSystem()->IsTileBasedGPU();
+    appPlayer->Render(clear, 255);
+    CServiceBroker::GetWinSystem()->GetGfxContext().SetRenderingResolution(m_coordsRes,
+                                                                           m_needsScaling);
+  }
   CGUIWindow::Render();
 }
 
